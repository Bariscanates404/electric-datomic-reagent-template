["^ ","~:output",["^ ","~:js","goog.provide('missionary.core');\n/**\n * \n * Same as `via`, except the expression to evaluate is provided as a zero-arity function on second argument.\n * \n * Not supported on clojurescript.\n * \n * ```clojure\n * (? (via-call blk read-line))\n * ;; reads a line from stdin and returns it\n * ```\n */\nmissionary.core.via_call = (function missionary$core$via_call(e,t){\nreturn (function (s,f){\nthrow (new Error(\"Unsupported operation.\"));\n});\n});\n/**\n * \n * Returns a task completing with given value (nil if not provided) after given duration (in milliseconds).\n * \n * Cancelling a sleep task makes it fail immediately.\n * \n * Example :\n * ```clojure\n * (? (sleep 1000 42))\n * #_=> 42               ;; 1 second later\n * ```\n */\nmissionary.core.sleep = (function missionary$core$sleep(var_args){\nvar G__30161 = arguments.length;\nswitch (G__30161) {\ncase 1:\nreturn missionary.core.sleep.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn missionary.core.sleep.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(missionary.core.sleep.cljs$core$IFn$_invoke$arity$1 = (function (d){\nreturn missionary.core.sleep.cljs$core$IFn$_invoke$arity$2(d,null);\n}));\n\n(missionary.core.sleep.cljs$core$IFn$_invoke$arity$2 = (function (d,x){\nreturn (function (s,f){\nreturn missionary.impl.Sleep.run(d,x,s,f);\n});\n}));\n\n(missionary.core.sleep.cljs$lang$maxFixedArity = 2);\n\n/**\n * \n * Returns a task running given `tasks` concurrently.\n * \n * If every task succeeds, `join` completes with the result of applying `f` to these results.\n * \n * If any task fails, others are cancelled then `join` fails with this error.\n * \n * Cancelling propagates to children tasks.\n * \n * Example :\n * ```clojure\n * (? (join vector (sleep 1000 1) (sleep 1000 2)))\n * #_=> [1 2]            ;; 1 second later\n * ```\n */\nmissionary.core.join = (function missionary$core$join(var_args){\nvar G__30170 = arguments.length;\nswitch (G__30170) {\ncase 1:\nreturn missionary.core.join.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nvar args_arr__5794__auto__ = [];\nvar len__5769__auto___30225 = arguments.length;\nvar i__5770__auto___30226 = (0);\nwhile(true){\nif((i__5770__auto___30226 < len__5769__auto___30225)){\nargs_arr__5794__auto__.push((arguments[i__5770__auto___30226]));\n\nvar G__30227 = (i__5770__auto___30226 + (1));\ni__5770__auto___30226 = G__30227;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5795__auto__ = (new cljs.core.IndexedSeq(args_arr__5794__auto__.slice((1)),(0),null));\nreturn missionary.core.join.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5795__auto__);\n\n}\n});\n\n(missionary.core.join.cljs$core$IFn$_invoke$arity$1 = (function (c){\nreturn (function (s,_){\nvar G__30174_30228 = (c.cljs$core$IFn$_invoke$arity$0 ? c.cljs$core$IFn$_invoke$arity$0() : c.call(null));\n(s.cljs$core$IFn$_invoke$arity$1 ? s.cljs$core$IFn$_invoke$arity$1(G__30174_30228) : s.call(null,G__30174_30228));\n\nreturn (function (){\nreturn null;\n});\n});\n}));\n\n(missionary.core.join.cljs$core$IFn$_invoke$arity$variadic = (function (c,ts){\nreturn (function (s,f){\nreturn missionary.impl.RaceJoin.run(false,c,ts,s,f);\n});\n}));\n\n/** @this {Function} */\n(missionary.core.join.cljs$lang$applyTo = (function (seq30168){\nvar G__30169 = cljs.core.first(seq30168);\nvar seq30168__$1 = cljs.core.next(seq30168);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30169,seq30168__$1);\n}));\n\n(missionary.core.join.cljs$lang$maxFixedArity = (1));\n\nmissionary.core.race_failure = (function missionary$core$race_failure(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___30229 = arguments.length;\nvar i__5770__auto___30230 = (0);\nwhile(true){\nif((i__5770__auto___30230 < len__5769__auto___30229)){\nargs__5775__auto__.push((arguments[i__5770__auto___30230]));\n\nvar G__30231 = (i__5770__auto___30230 + (1));\ni__5770__auto___30230 = G__30231;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((0) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((0)),(0),null)):null);\nreturn missionary.core.race_failure.cljs$core$IFn$_invoke$arity$variadic(argseq__5776__auto__);\n});\n\n(missionary.core.race_failure.cljs$core$IFn$_invoke$arity$variadic = (function (errors){\nreturn cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Race failure.\",new cljs.core.PersistentArrayMap(null, 1, [new cljs.core.Keyword(\"missionary.core\",\"errors\",\"missionary.core/errors\",-661055151),errors], null));\n}));\n\n(missionary.core.race_failure.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(missionary.core.race_failure.cljs$lang$applyTo = (function (seq30175){\nvar self__5755__auto__ = this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq30175));\n}));\n\n/**\n * \n * Returns a task running given `tasks` concurrently.\n * \n * If any task succeeds, others are cancelled then `race` completes with this result.\n * \n * If every task fails, `race` fails.\n * \n * Cancelling propagates to children tasks.\n * \n * Example :\n * ```clojure\n * (? (race (sleep 1000 1) (sleep 2000 2)))\n * #_=> 1                 ;; 1 second later\n * ```\n */\nmissionary.core.race = (function missionary$core$race(var_args){\nvar G__30178 = arguments.length;\nswitch (G__30178) {\ncase 0:\nreturn missionary.core.race.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ndefault:\nvar args_arr__5794__auto__ = [];\nvar len__5769__auto___30233 = arguments.length;\nvar i__5770__auto___30234 = (0);\nwhile(true){\nif((i__5770__auto___30234 < len__5769__auto___30233)){\nargs_arr__5794__auto__.push((arguments[i__5770__auto___30234]));\n\nvar G__30235 = (i__5770__auto___30234 + (1));\ni__5770__auto___30234 = G__30235;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5795__auto__ = (new cljs.core.IndexedSeq(args_arr__5794__auto__.slice((0)),(0),null));\nreturn missionary.core.race.cljs$core$IFn$_invoke$arity$variadic(argseq__5795__auto__);\n\n}\n});\n\n(missionary.core.race.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn (function (_,f){\nvar G__30179_30236 = missionary.core.race_failure();\n(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(G__30179_30236) : f.call(null,G__30179_30236));\n\nreturn (function (){\nreturn null;\n});\n});\n}));\n\n(missionary.core.race.cljs$core$IFn$_invoke$arity$variadic = (function (ts){\nreturn (function (s,f){\nreturn missionary.impl.RaceJoin.run(true,missionary.core.race_failure,ts,s,f);\n});\n}));\n\n/** @this {Function} */\n(missionary.core.race.cljs$lang$applyTo = (function (seq30177){\nvar self__5755__auto__ = this;\nreturn self__5755__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq30177));\n}));\n\n(missionary.core.race.cljs$lang$maxFixedArity = (0));\n\n/**\n * \n * Returns a task always succeeding with result of given `task` wrapped in a zero-argument function returning result if successful or throwing exception if failed.\n */\nmissionary.core.attempt = (function missionary$core$attempt(task){\nreturn (function (s,_){\nvar G__30180 = (function (x){\nvar G__30182 = (function (){\nreturn x;\n});\nreturn (s.cljs$core$IFn$_invoke$arity$1 ? s.cljs$core$IFn$_invoke$arity$1(G__30182) : s.call(null,G__30182));\n});\nvar G__30181 = (function (e){\nvar G__30183 = (function (){\nthrow e;\n});\nreturn (s.cljs$core$IFn$_invoke$arity$1 ? s.cljs$core$IFn$_invoke$arity$1(G__30183) : s.call(null,G__30183));\n});\nreturn (task.cljs$core$IFn$_invoke$arity$2 ? task.cljs$core$IFn$_invoke$arity$2(G__30180,G__30181) : task.call(null,G__30180,G__30181));\n});\n});\n/**\n * \n * Returns a task running given `task` completing with a zero-argument function and completing with the result of this function call.\n */\nmissionary.core.absolve = (function missionary$core$absolve(task){\nreturn (function (s,f){\nvar G__30184 = (function (t){\ntry{var G__30187 = (t.cljs$core$IFn$_invoke$arity$0 ? t.cljs$core$IFn$_invoke$arity$0() : t.call(null));\nreturn (s.cljs$core$IFn$_invoke$arity$1 ? s.cljs$core$IFn$_invoke$arity$1(G__30187) : s.call(null,G__30187));\n}catch (e30186){var e = e30186;\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(e) : f.call(null,e));\n}});\nvar G__30185 = f;\nreturn (task.cljs$core$IFn$_invoke$arity$2 ? task.cljs$core$IFn$_invoke$arity$2(G__30184,G__30185) : task.call(null,G__30184,G__30185));\n});\n});\n/**\n * \n * Returns a task running given `task` and completing with its result if available within specified `delay` (in\n * milliseconds). Otherwise, input is cancelled and the process succeeds with `value`, or `nil` if not provided.\n * \n * ```clojure\n * (m/? (m/timeout (m/sleep 20 :a) 25 :b)) ;; :a after 20ms\n * (m/? (m/timeout (m/sleep 20 :a) 15 :b)) ;; :b after 15ms\n * (m/? (m/timeout (m/sleep 20 :a) 15))    ;; nil after 15ms\n * ```\n */\nmissionary.core.timeout = (function() {\nvar missionary$core$timeout = null;\nvar missionary$core$timeout__2 = (function (task,delay){\nreturn missionary$core$timeout.cljs$core$IFn$_invoke$arity$3(task,delay,null);\n});\nvar missionary$core$timeout__3 = (function (task,delay,value){\nreturn missionary.core.absolve(missionary.core.race.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([missionary.core.attempt(task),missionary.core.sleep.cljs$core$IFn$_invoke$arity$2(delay,(function (){\nreturn value;\n}))], 0)));\n});\nmissionary$core$timeout = function(task,delay,value){\nswitch(arguments.length){\ncase 2:\nreturn missionary$core$timeout__2.call(this,task,delay);\ncase 3:\nreturn missionary$core$timeout__3.call(this,task,delay,value);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nmissionary$core$timeout.cljs$core$IFn$_invoke$arity$2 = missionary$core$timeout__2;\nmissionary$core$timeout.cljs$core$IFn$_invoke$arity$3 = missionary$core$timeout__3;\nreturn missionary$core$timeout;\n})()\n;\nmissionary.core.check = (function missionary$core$check(){\nreturn missionary.impl.Fiber.current().missionary$impl$Fiber$Fiber$check$arity$1(null);\n});\nmissionary.core.park = (function missionary$core$park(task){\nreturn missionary.impl.Fiber.current().missionary$impl$Fiber$Fiber$park$arity$2(null,task);\n});\nmissionary.core.switch$ = (function missionary$core$switch(flow){\nreturn missionary.impl.Fiber.current().missionary$impl$Fiber$Fiber$swich$arity$2(null,flow);\n});\nmissionary.core.fork = (function missionary$core$fork(par,flow){\nif((par > (0))){\n} else {\nthrow (new Error([\"Assert failed: \",\"Non-positive parallelism.\",\"\\n\",\"(pos? par)\"].join('')));\n}\n\nreturn missionary.impl.Fiber.current().missionary$impl$Fiber$Fiber$fork$arity$3(null,par,flow);\n});\nmissionary.core.unpark = (function missionary$core$unpark(){\nreturn missionary.impl.Fiber.current().missionary$impl$Fiber$Fiber$unpark$arity$1(null);\n});\nmissionary.core.sp_run = (function missionary$core$sp_run(c,s,f){\nreturn missionary.impl.Sequential.run(c,s,f);\n});\nmissionary.core.ap_run = (function missionary$core$ap_run(c,n,t){\nreturn missionary.impl.Ambiguous.run(c,n,t);\n});\nmissionary.core.cp_STAR_ = (function missionary$core$cp_STAR_(cr){\nreturn (missionary.impl.Continuous.flow.cljs$core$IFn$_invoke$arity$1 ? missionary.impl.Continuous.flow.cljs$core$IFn$_invoke$arity$1(cr) : missionary.impl.Continuous.flow.call(null,cr));\n});\n/**\n * \n * Inhibits cancellation signal of given `task`.\n */\nmissionary.core.compel = (function missionary$core$compel(task){\nreturn (function (s,f){\n(task.cljs$core$IFn$_invoke$arity$2 ? task.cljs$core$IFn$_invoke$arity$2(s,f) : task.call(null,s,f));\n\nreturn (function (){\nreturn null;\n});\n});\n});\n/**\n * \n * Creates an instance of dataflow variable (aka single-assignment).\n * \n * A dataflow variable is a function implementing `assign` on 1-arity and `deref` on 2-arity (as task). `assign` immediately binds the variable to given value if not already bound and returns bound value. `deref` is a task completing with the value bound to the variable as soon as it's available.\n * \n * Cancelling a `deref` task makes it fail immediately.\n * ```\n */\nmissionary.core.dfv = (function missionary$core$dfv(){\nreturn missionary.impl.Dataflow.make();\n});\n/**\n * \n * Creates an instance of mailbox.\n * \n * A mailbox is a function implementing `post` on 1-arity and `fetch` on 2-arity (as task). `post` immediately pushes given value to mailbox and returns nil. `fetch` is a task pulling a value from mailbox as soon as it's non-empty and completing with this value.\n * \n * Cancelling a `fetch` task makes it fail immediately.\n * \n * Example : an actor is a mailbox associated with a process consuming messages.\n * ```clojure\n * (defn crash [^Throwable e]                                ;; let it crash philosophy\n *   (.printStackTrace e)\n *   (System/exit -1))\n * \n * (defn actor\n *   ([init] (actor init crash))\n *   ([init fail]\n * (let [self (mbx)]\n *   ((sp\n *      (loop [b init]\n *        (recur (b self (? self)))))\n *     nil fail)\n *   self)))\n * \n * (def counter\n *   (actor\n *  ((fn beh [n]\n *     (fn [self cust]\n *       (cust n)\n *       (beh (inc n)))) 0)))\n * \n * (counter prn)                                             ;; prints 0\n * (counter prn)                                             ;; prints 1\n * (counter prn)                                             ;; prints 2\n * ```\n */\nmissionary.core.mbx = (function missionary$core$mbx(){\nreturn missionary.impl.Mailbox.make();\n});\n/**\n * \n * Creates an instance of synchronous rendez-vous.\n * \n * A synchronous rendez-vous is a function implementing `give` on its 1-arity and `take` on its 2-arity (as task). `give` takes a value to be transferred and returns a task completing with nil as soon as a taker is available. `take` is a task completing with transferred value as soon as a giver is available.\n * \n * Cancelling `give` and `take` tasks makes them fail immediately.\n * \n * Example : producer / consumer stream communication\n * ```clojure\n * (defn reducer [rf i take]\n *   (sp\n *  (loop [r i]\n *    (let [x (? take)]\n *      (if (identical? x take)\n *        r (recur (rf r x)))))))\n * \n * (defn iterator [give xs]\n *   (sp\n *  (loop [xs (seq xs)]\n *    (if-some [[x & xs] xs]\n *      (do (? (give x))\n *          (recur xs))\n *      (? (give give))))))\n * \n * (def stream (rdv))\n * \n * (? (join {} (iterator stream (range 100)) (reducer + 0 stream)))      ;; returns 4950\n * ```\n */\nmissionary.core.rdv = (function missionary$core$rdv(){\nreturn missionary.impl.Rendezvous.make();\n});\n/**\n * \n * Creates a semaphore initialized with n tokens (1 if not provided, aka mutex).\n * \n * A semaphore is a function implementing `release` on 0-arity and `acquire` on 2-arity (as task). `release` immediately makes a token available and returns nil. `acquire` is a task completing with nil as soon as a token is available.\n * \n * Cancelling an `acquire` task makes it fail immediately.\n * \n * Example : dining philosophers\n * ```clojure\n * (defn phil [name f1 f2]\n *   (sp\n *  (while true\n *    (prn name :thinking)\n *    (? (sleep 500))\n *    (holding f1\n *      (holding f2\n *        (prn name :eating)\n *        (? (sleep 600)))))))\n * \n * (def forks (vec (repeatedly 5 sem)))\n * \n * (? (timeout 10000\n *   (join vector\n *     (phil \"descartes\" (forks 0) (forks 1))\n *     (phil \"hume\"      (forks 1) (forks 2))\n *     (phil \"plato\"     (forks 2) (forks 3))\n *     (phil \"nietzsche\" (forks 3) (forks 4))\n *     (phil \"kant\"      (forks 0) (forks 4)))))\n * ```\n */\nmissionary.core.sem = (function missionary$core$sem(var_args){\nvar G__30214 = arguments.length;\nswitch (G__30214) {\ncase 0:\nreturn missionary.core.sem.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn missionary.core.sem.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(missionary.core.sem.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn missionary.core.sem.cljs$core$IFn$_invoke$arity$1((1));\n}));\n\n(missionary.core.sem.cljs$core$IFn$_invoke$arity$1 = (function (n){\nreturn missionary.impl.Semaphore.make(n);\n}));\n\n(missionary.core.sem.cljs$lang$maxFixedArity = 1);\n\nmissionary.core.never = cljs.core.with_meta((function missionary$core$never(_,f){\nreturn missionary.impl.Never.run(f);\n}),new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"static\",\"static\",1214358571),true,new cljs.core.Keyword(null,\"doc\",\"doc\",1913296891),\"\\nA task never succeeding. Cancelling makes it fail immediately.\"], null));\n/**\n * \n * The empty flow. Doesn't produce any value and terminates immediately. Cancelling has no effect.\n * \n * Example :\n * ```clojure\n * (? (reduce conj none))\n * #_=> []\n * ```\n */\nmissionary.core.none = (function missionary$core$none(_,t){\n(t.cljs$core$IFn$_invoke$arity$0 ? t.cljs$core$IFn$_invoke$arity$0() : t.call(null));\n\nreturn (function (){\nreturn null;\n});\n});\n/**\n * \n * Returns a discrete flow producing values from given `collection`. Cancelling before having reached the end makes the flow fail immediately.\n */\nmissionary.core.seed = (function missionary$core$seed(coll){\nreturn (function (n,t){\nreturn missionary.impl.Seed.run(coll,n,t);\n});\n});\n/**\n * Alias for `seed`\n */\nmissionary.core.enumerate = missionary.core.seed;\n/**\n * \n * Returns a task reducing values produced by given discrete `flow` with `rf`, starting with `init` (or, if not provided, the result of calling `rf` with no argument).\n * \n * Cancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n * \n * Example :\n * ```clojure\n * (? (reduce + (seed (range 10))))\n * #_=> 45\n * ```\n */\nmissionary.core.reduce = (function missionary$core$reduce(var_args){\nvar G__30217 = arguments.length;\nswitch (G__30217) {\ncase 2:\nreturn missionary.core.reduce.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn missionary.core.reduce.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(missionary.core.reduce.cljs$core$IFn$_invoke$arity$2 = (function (rf,flow){\nreturn (function (s,f){\nreturn missionary.impl.Reduce.run(rf,flow,s,f);\n});\n}));\n\n(missionary.core.reduce.cljs$core$IFn$_invoke$arity$3 = (function (rf,i,flow){\nreturn missionary.core.reduce.cljs$core$IFn$_invoke$arity$2((function() {\nvar G__30250 = null;\nvar G__30250__0 = (function (){\nreturn i;\n});\nvar G__30250__2 = (function (r,x){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(r,x) : rf.call(null,r,x));\n});\nG__30250 = function(r,x){\nswitch(arguments.length){\ncase 0:\nreturn G__30250__0.call(this);\ncase 2:\nreturn G__30250__2.call(this,r,x);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__30250.cljs$core$IFn$_invoke$arity$0 = G__30250__0;\nG__30250.cljs$core$IFn$_invoke$arity$2 = G__30250__2;\nreturn G__30250;\n})()\n,flow);\n}));\n\n(missionary.core.reduce.cljs$lang$maxFixedArity = 3);\n\n/**\n * Alias for `reduce`\n */\nmissionary.core.aggregate = missionary.core.reduce;\n/**\n * \n * Returns a continuous flow reflecting the current state of a reference type. `reference` must support `add-watch`,\n * `remove-watch` and `deref`. On initialization, the process is ready to transfer. On transfer, the current state is\n * returned. Whenever the state of the reference changes and a transfer is not pending, the process becomes ready to\n * transfer again. Cancelling the process makes it fail immediately with an instance of `missionary.Cancelled` and\n * terminates the process.\n */\nmissionary.core.watch = (function missionary$core$watch(r){\nreturn (function (n,t){\nreturn missionary.impl.Watch.run(r,n,t);\n});\n});\n/**\n * \n * Returns a discrete flow observing values produced by a non-backpressured subject. `subject` must be a function taking a\n * callback and returning a cleanup thunk. On initialization, the process calls the subject with a fresh callback. Passing\n * a value to the callback makes the process ready to transfer this value. Cancelling the process makes it fail immediately\n * with an instance of `missionary.Cancelled` and terminates the process. The cleanup thunk is called on termination. The\n * callback throws an `Error` if the process is cancelled or terminated, or if a transfer is pending.\n */\nmissionary.core.observe = (function missionary$core$observe(s){\nreturn (function (n,t){\nreturn missionary.impl.Observe.run(s,n,t);\n});\n});\n/**\n * \n * Returns a discrete flow running given discrete `flow` and transforming values with the composition of given transducers `xf*`.\n * \n * Cancelling propagates to upstream flow. Early termination by the transducing stage (via `reduced` or throwing) cancels upstream flow.\n * \n * Example :\n * ```clojure\n * (? (->> (seed (range 10))\n *      (eduction (filter odd?) (mapcat range) (partition-all 4))\n *      (reduce conj)))\n * #_=> [[0 0 1 2] [0 1 2 3] [4 0 1 2] [3 4 5 6] [0 1 2 3] [4 5 6 7] [8]]\n * ```\n * @param {...*} var_args\n */\nmissionary.core.eduction = (function() {\nvar missionary$core$e = null;\nvar missionary$core$e__1 = (function (f){\nreturn f;\n});\nvar missionary$core$e__2 = (function (x,f){\nreturn (function (n,t){\nreturn missionary.impl.Eduction.run(x,f,n,t);\n});\n});\nvar missionary$core$e__3 = (function() { \nvar G__30261__delegate = function (x,y,zs){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(missionary$core$e,cljs.core.comp.cljs$core$IFn$_invoke$arity$2(x,y),zs);\n};\nvar G__30261 = function (x,y,var_args){\nvar zs = null;\nif (arguments.length > 2) {\nvar G__30262__i = 0, G__30262__a = new Array(arguments.length -  2);\nwhile (G__30262__i < G__30262__a.length) {G__30262__a[G__30262__i] = arguments[G__30262__i + 2]; ++G__30262__i;}\n  zs = new cljs.core.IndexedSeq(G__30262__a,0,null);\n} \nreturn G__30261__delegate.call(this,x,y,zs);};\nG__30261.cljs$lang$maxFixedArity = 2;\nG__30261.cljs$lang$applyTo = (function (arglist__30263){\nvar x = cljs.core.first(arglist__30263);\narglist__30263 = cljs.core.next(arglist__30263);\nvar y = cljs.core.first(arglist__30263);\nvar zs = cljs.core.rest(arglist__30263);\nreturn G__30261__delegate(x,y,zs);\n});\nG__30261.cljs$core$IFn$_invoke$arity$variadic = G__30261__delegate;\nreturn G__30261;\n})()\n;\nmissionary$core$e = function(x,y,var_args){\nvar zs = var_args;\nswitch(arguments.length){\ncase 1:\nreturn missionary$core$e__1.call(this,x);\ncase 2:\nreturn missionary$core$e__2.call(this,x,y);\ndefault:\nvar G__30265 = null;\nif (arguments.length > 2) {\nvar G__30267__i = 0, G__30267__a = new Array(arguments.length -  2);\nwhile (G__30267__i < G__30267__a.length) {G__30267__a[G__30267__i] = arguments[G__30267__i + 2]; ++G__30267__i;}\nG__30265 = new cljs.core.IndexedSeq(G__30267__a,0,null);\n}\nreturn missionary$core$e__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__30265);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nmissionary$core$e.cljs$lang$maxFixedArity = 2;\nmissionary$core$e.cljs$lang$applyTo = missionary$core$e__3.cljs$lang$applyTo;\nmissionary$core$e.cljs$core$IFn$_invoke$arity$1 = missionary$core$e__1;\nmissionary$core$e.cljs$core$IFn$_invoke$arity$2 = missionary$core$e__2;\nmissionary$core$e.cljs$core$IFn$_invoke$arity$variadic = missionary$core$e__3.cljs$core$IFn$_invoke$arity$variadic;\nreturn missionary$core$e;\n})()\n;\n/**\n * Alias for `eduction`\n */\nmissionary.core.transform = missionary.core.eduction;\n/**\n * \n * Returns a discrete flow running given discrete `flow` and emitting given `init` value (or, if not provided, the result of calling `rf` with no argument) followed by successive reductions (by rf) of upstream values with previously emitted value.\n * \n * Cancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n * \n * Example :\n * ```clojure\n * (? (->> [1 2 3 4 5]\n *      (seed)\n *      (reductions +)\n *      (reduce conj)))\n * #_=> [0 1 3 6 10 15]\n * ```\n */\nmissionary.core.reductions = (function missionary$core$reductions(var_args){\nvar G__30219 = arguments.length;\nswitch (G__30219) {\ncase 2:\nreturn missionary.core.reductions.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn missionary.core.reductions.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(missionary.core.reductions.cljs$core$IFn$_invoke$arity$2 = (function (rf,f){\nreturn (function (n,t){\nreturn missionary.impl.Reductions.run(rf,f,n,t);\n});\n}));\n\n(missionary.core.reductions.cljs$core$IFn$_invoke$arity$3 = (function (rf,i,f){\nreturn missionary.core.reductions.cljs$core$IFn$_invoke$arity$2((function() {\nvar G__30271 = null;\nvar G__30271__0 = (function (){\nreturn i;\n});\nvar G__30271__2 = (function (r,x){\nreturn (rf.cljs$core$IFn$_invoke$arity$2 ? rf.cljs$core$IFn$_invoke$arity$2(r,x) : rf.call(null,r,x));\n});\nG__30271 = function(r,x){\nswitch(arguments.length){\ncase 0:\nreturn G__30271__0.call(this);\ncase 2:\nreturn G__30271__2.call(this,r,x);\n}\nthrow(new Error('Invalid arity: ' + arguments.length));\n};\nG__30271.cljs$core$IFn$_invoke$arity$0 = G__30271__0;\nG__30271.cljs$core$IFn$_invoke$arity$2 = G__30271__2;\nreturn G__30271;\n})()\n,f);\n}));\n\n(missionary.core.reductions.cljs$lang$maxFixedArity = 3);\n\n/**\n * Alias for `reductions`\n */\nmissionary.core.integrate = missionary.core.reductions;\n/**\n * \n * Returns a `org.reactivestreams.Publisher` running given discrete `flow` on each subscription.\n */\nmissionary.core.publisher = (function missionary$core$publisher(f){\nthrow (new Error(\"Unsupported operation.\"));\n});\n/**\n * \n * Returns a discrete flow subscribing to given `org.reactivestreams.Publisher`.\n */\nmissionary.core.subscribe = (function missionary$core$subscribe(pub){\nthrow (new Error(\"Unsupported operation.\"));\n});\n/**\n * \n * Returns a continuous flow producing values emitted by given discrete `flow`, relieving backpressure. When upstream is faster than downstream, overflowed values are successively reduced with given function `rf`.\n * \n * Cancelling propagates to upstream. If `rf` throws, upstream `flow` is cancelled.\n * \n * Example :\n * ```clojure\n * ;; Delays each `input` value by `delay` milliseconds\n * (defn delay-each [delay input]\n *   (ap (? (sleep delay (?> input)))))\n * \n * (? (->> (ap (let [n (?> (seed [24 79 67 34 18 9 99 37]))]\n *            (? (sleep n n))))\n *      (relieve +)\n *      (delay-each 80)\n *      (reduce conj)))\n * #_=> [24 79 67 61 99 37]\n * ```\n */\nmissionary.core.relieve = (function missionary$core$relieve(rf,f){\nreturn (function (n,t){\nreturn missionary.impl.Relieve.run(rf,f,n,t);\n});\n});\n/**\n * \n * Returns a discrete flow producing values emitted by given discrete `flow`, accumulating upstream overflow up to `capacity` items.\n */\nmissionary.core.buffer = (function missionary$core$buffer(c,f){\nif((c > (0))){\n} else {\nthrow (new Error([\"Assert failed: \",\"Non-positive buffer capacity.\",\"\\n\",\"(pos? c)\"].join('')));\n}\n\nreturn (missionary.impl.Buffer.flow.cljs$core$IFn$_invoke$arity$2 ? missionary.impl.Buffer.flow.cljs$core$IFn$_invoke$arity$2(c,f) : missionary.impl.Buffer.flow.call(null,c,f));\n});\n/**\n * \n * Returns a flow running an arbitrary number of flows concurrently. The process is ready to transfer when at least one\n * input is ready to transfer. On transfer, all ready inputs are transferred, the function is called with the latest\n * value of each input and the result is returned. If an input emits consecutive values, all of them are transferred and\n * only the latest one is retained. Each input must be initially ready.\n * \n * Input failures and exceptions thrown by `f` cancel the process and propagate the error. The process terminates when all\n * inputs are terminated. Cancelling the process cancels all inputs.\n * \n * ```clojure\n * (defn sleep-emit [delays]\n *   (reductions {} 0\n *  (ap (let [n (?> (seed delays))]\n *        (? (sleep n n))))))\n * \n * (defn delay-each [delay input]\n *   (ap (? (sleep delay (?> input)))))\n * \n * (? (->> (latest vector\n *        (sleep-emit [24 79 67 34])\n *        (sleep-emit [86 12 37 93]))\n *      (delay-each 50)\n *      (reduce conj)))\n * \n * #_=> [[0 0] [24 0] [24 86] [79 12] [79 37] [67 37] [34 93]]\n * ```\n * @param {...*} var_args\n */\nmissionary.core.latest = (function() { \nvar missionary$core$latest__delegate = function (c,fs){\nreturn (function (n,t){\nreturn missionary.impl.Latest.run(c,fs,n,t);\n});\n};\nvar missionary$core$latest = function (c,var_args){\nvar fs = null;\nif (arguments.length > 1) {\nvar G__30284__i = 0, G__30284__a = new Array(arguments.length -  1);\nwhile (G__30284__i < G__30284__a.length) {G__30284__a[G__30284__i] = arguments[G__30284__i + 1]; ++G__30284__i;}\n  fs = new cljs.core.IndexedSeq(G__30284__a,0,null);\n} \nreturn missionary$core$latest__delegate.call(this,c,fs);};\nmissionary$core$latest.cljs$lang$maxFixedArity = 1;\nmissionary$core$latest.cljs$lang$applyTo = (function (arglist__30285){\nvar c = cljs.core.first(arglist__30285);\nvar fs = cljs.core.rest(arglist__30285);\nreturn missionary$core$latest__delegate(c,fs);\n});\nmissionary$core$latest.cljs$core$IFn$_invoke$arity$variadic = missionary$core$latest__delegate;\nreturn missionary$core$latest;\n})()\n;\n/**\n * \n * Returns a flow running an arbitrary number of sampled flows concurrently with a sampler flow. The process is ready to\n * transfer when the sampler is ready to transfer. On transfer, all ready inputs are transferred, the function is called\n * with the latest value of each input and the result is returned. If a sampled input emits consecutive values, all of\n * them are transferred and only the latest one is retained. Each sampled input must be initially ready.\n * \n * When the sampler input terminates, all sampled inputs are cancelled. Input failures and exceptions thrown by `f` cancel\n * the process, and propagate the error. The process terminates when all input flows are terminated. Cancelling the process\n * cancels the sampler input.\n * \n * Example :\n * ```clojure\n * (defn sleep-emit [delays]\n *   (ap (let [n (?> (seed delays))]\n *      (? (sleep n n)))))\n * \n * (defn delay-each [delay input]\n *   (ap (? (sleep delay (?> input)))))\n * \n * (m/? (->> (m/sample vector\n *          (m/reductions {} 0 (sleep-emit [24 79 67 34]))\n *          (sleep-emit [86 12 37 93]))\n *     (delay-each 50)\n *     (m/reduce conj)))\n * \n * #_=> [[24 86] [24 12] [79 37] [67 93]]\n * ```\n * @param {...*} var_args\n */\nmissionary.core.sample = (function() { \nvar missionary$core$sample__delegate = function (c,f,fs){\nreturn (function (n,t){\nreturn missionary.impl.Sample.run(c,f,fs,n,t);\n});\n};\nvar missionary$core$sample = function (c,f,var_args){\nvar fs = null;\nif (arguments.length > 2) {\nvar G__30287__i = 0, G__30287__a = new Array(arguments.length -  2);\nwhile (G__30287__i < G__30287__a.length) {G__30287__a[G__30287__i] = arguments[G__30287__i + 2]; ++G__30287__i;}\n  fs = new cljs.core.IndexedSeq(G__30287__a,0,null);\n} \nreturn missionary$core$sample__delegate.call(this,c,f,fs);};\nmissionary$core$sample.cljs$lang$maxFixedArity = 2;\nmissionary$core$sample.cljs$lang$applyTo = (function (arglist__30288){\nvar c = cljs.core.first(arglist__30288);\narglist__30288 = cljs.core.next(arglist__30288);\nvar f = cljs.core.first(arglist__30288);\nvar fs = cljs.core.rest(arglist__30288);\nreturn missionary$core$sample__delegate(c,f,fs);\n});\nmissionary$core$sample.cljs$core$IFn$_invoke$arity$variadic = missionary$core$sample__delegate;\nreturn missionary$core$sample;\n})()\n;\n/**\n * \n * Returns a discrete flow running given discrete `flows` concurrently and emitting the result of applying `f` to the set of first values emitted by each upstream flow, followed by the result of applying `f` to the set of second values and so on, until any upstream flow terminates, at which point the flow will cancel all other upstream flows and wait for their termination.\n * \n * Cancelling propagates to every upstream flow. If any upstream flow fails or if `f` throws, the flow is cancelled.\n * \n * Example :\n * ```clojure\n * (m/? (->> (m/zip vector\n *               (m/seed [1 2 3])\n *               (m/seed [:a :b :c]))\n *        (m/reduce conj)))\n * #_=> [[1 :a] [2 :b] [3 :c]]\n * ```\n */\nmissionary.core.zip = (function missionary$core$zip(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___30290 = arguments.length;\nvar i__5770__auto___30291 = (0);\nwhile(true){\nif((i__5770__auto___30291 < len__5769__auto___30290)){\nargs__5775__auto__.push((arguments[i__5770__auto___30291]));\n\nvar G__30292 = (i__5770__auto___30291 + (1));\ni__5770__auto___30291 = G__30292;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((2) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn missionary.core.zip.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(missionary.core.zip.cljs$core$IFn$_invoke$arity$variadic = (function (c,f,fs){\nreturn (function (n,t){\nreturn missionary.impl.Zip.run(c,cljs.core.cons(f,fs),n,t);\n});\n}));\n\n(missionary.core.zip.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(missionary.core.zip.cljs$lang$applyTo = (function (seq30220){\nvar G__30221 = cljs.core.first(seq30220);\nvar seq30220__$1 = cljs.core.next(seq30220);\nvar G__30222 = cljs.core.first(seq30220__$1);\nvar seq30220__$2 = cljs.core.next(seq30220__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__30221,G__30222,seq30220__$2);\n}));\n\n/**\n * \n * Returns a discrete flow running given discrete flow, calling given key function on each produced value, grouping values\n * according to keys returned by the function, and producing a key-group pair for each grouping found. A group is a flow\n * consuming values matching a key. Upstream values are dispatched in constant time to their group consumer.\n * \n * Cancelling a group consumer makes it fail immediately. If a value is subsequently found for the same grouping, the\n * key-group pair is produced again, including in the special case where the consumer is cancelled while a transfer was\n * pending. Cancelling a group consumer has no effect when the main process is cancelled.\n * \n * If upstream fails, or if the key function throws, then upstream is cancelled and flushed and the error is propagated\n * downstream.\n * \n * When the last upstream value is consumed, downstream terminates along with each active consumer and subsequent ones.\n * \n * Concurrent consumers on a single group are not allowed, attempting to do so will fail the latest consumer.\n * \n * Example :\n * ```clojure\n * (def words [\"Air\" \"Bud\" \"Cup\" \"Awake\" \"Break\" \"Chunk\" \"Ant\" \"Big\" \"Check\"])\n * (def groups\n *   (m/ap (let [[k >x] (m/?= (m/group-by (juxt first count) (m/seed words)))]\n *        [k (m/? (m/reduce conj >x))])))\n * (m/? (m/reduce conj {} groups))\n * #_=> {[\\C 3] [\"Cup\"],\n *    [\\B 5] [\"Break\"],\n *    [\\A 5] [\"Awake\"],\n *    [\\B 3] [\"Bud\" \"Big\"],\n *    [\\A 3] [\"Air\" \"Ant\"],\n *    [\\C 5] [\"Chunk\" \"Check\"]}\n * ```\n */\nmissionary.core.group_by = (function missionary$core$group_by(kf,f){\nreturn (function (n,t){\nreturn missionary.impl.GroupBy.run(kf,f,n,t);\n});\n});\n/**\n * \n * Experimental. To be deprecated in favor of [lazy publishers](https://github.com/leonoel/missionary/issues/70)\n */\nmissionary.core.reactor_call = (function missionary$core$reactor_call(i){\nreturn (function (s,f){\nreturn missionary.impl.Reactor.run(i,s,f);\n});\n});\n/**\n * \n * Spawns a discrete publisher from given flow, see `reactor-call`.\n */\nmissionary.core.stream_BANG_ = (function missionary$core$stream_BANG_(f){\nreturn missionary.impl.Reactor.publish(f,false);\n});\n/**\n * \n * Spawns a continuous publisher from given flow, see `reactor-call`.\n */\nmissionary.core.signal_BANG_ = (function missionary$core$signal_BANG_(f){\nreturn missionary.impl.Reactor.publish(f,true);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","missionary/core.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",20],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.math","~$cljs.math","~$clojure.core","~$cljs.core"],"~:use-macros",["^ ","~$amb>","~$missionary.core","~$?!","^H","~$amb=","^H","~$!","^H","~$reactor","^H","~$?<","^H","~$sp","^H","~$holding","^H","~$cr","~$cloroutine.core","~$?=","^H","~$?","^H","~$cp","^H","~$amb","^H","~$??","^H","~$?>","^H","~$ap","^H"],"~:excludes",["~#set",["~$eduction","~$reduce","~$group-by","~$reductions"]],"~:macros",["^ ","^G",["^ ","~:ns","^H","~:name","~$missionary.core/amb>","^6","missionary/core.cljc","^8",1,"^7",514,"~:macro",true,"~:deprecated",true,"~:arglists",["~#list",[["~$&","~$forms"]]],"~:doc","Alias for `amb`"],"^I",["^ ","^12","^H","^13","~$missionary.core/?!","^6","missionary/core.cljc","^8",1,"^7",265,"^15",true,"^16",true,"^17",["^18",[["~$f"]]],"^1:","Alias for `?<`"],"^J",["^ ","^17",["^18",[[],["~$form"],["^1<","~$&","^19"]]],"^1:","In an `ap` block, evaluates each form concurrently and returns results in order of availability.","^7",502,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/amb=","^12","^H","^15",true],"~$!",["^ ","^17",["^18",[[]]],"^1:","\nThrows an instance of `missionary.Cancelled` if current evaluation context is interrupted, otherwise returns nil. The\nevaluation context defaults to the current thread if the host platform supports it, and can be redefined with `sp`,\n`ap`, or `cp`.\n","^7",191,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/!","^12","^H","^15",true],"^K",["^ ","^17",["^18",[["~$&","~$body"]]],"^1:","\nCalls `reactor-call` with a function evaluating given `body` in an implicit `do`.\n","^7",800,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/reactor","^12","^H","^15",true],"^L",["^ ","^17",["^18",[["~$flow"]]],"^1:","\nForks current evaluation context by given flow. Evaluation resumes whenever the flow transfers, result is returned or\nrethrown according to transfer status. Each transfer creates a new processing branch and defines a new evaluation\ncontext inherited from its parent. Concurrent processing branches are not allowed, and the current processing branch is\ninterrupted when the forking flow becomes ready to transfer again. Interrupting the parent evaluation context cancels\nthe forking flow and interrupts all processing branches currently being run and those subsequently run. The evaluation\ncontext is undefined by default and can be defined with `ap` or `cp`.\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(import missionary.Cancelled)\n\n(defn debounce [delay flow]\n  (m/ap (let [x (m/?< flow)]\n          (try (m/? (m/sleep delay x))\n               (catch Cancelled _ (m/amb))))))\n\n(m/? (->> (m/ap (let [n (m/amb 24 79 67 34 18 9 99 37)]\n                  (m/? (m/sleep n n))))\n       (debounce 50)\n       (m/reduce conj)))\n#_=> [24 79 9 37]\n```\n","^7",238,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/?<","^12","^H","^15",true],"^M",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nReturns a task evaluating `body` (in an implicit `do`) in a new evaluation context and completing its result. Body\nevaluation can be parked by a task with `?`. Cancelling a `sp` process interrupts its evaluation context.\n","^7",277,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/sp","^12","^H","^15",true],"^N",["^ ","^17",["^18",[["~$lock","~$&","^1?"]]],"^1:","\n`acquire`s given `semaphore` and evaluates `body` (in an implicit `do`), ensuring `semaphore` is `release`d after evaluation.\n","^7",449,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/holding","^12","^H","^15",true],"~$via",["^ ","^17",["^18",[["~$exec","~$&","^1?"]]],"^1:","\nReturns a task evaluating body (in an implicit `do`) on given `java.util.concurrent.Executor` and completing with its result.\n\nCancellation interrupts the evaluating thread.\n\nNot supported on clojurescript.\n\nExample :\n```clojure\n\n```\n","^7",41,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/via","^12","^H","^15",true],"^Q",["^ ","^12","^H","^13","~$missionary.core/?=","^6","missionary/core.cljc","^8",1,"^7",270,"^15",true,"^16",true,"^17",["^18",[["^1A"]]],"^1:","Alias for `(?> ##Inf flow)`"],"~$?",["^ ","^17",["^18",[["~$task"]]],"^1:","\nParks current evaluation context by given task. Evaluation resumes when the task completes, result is returned or\nrethrown according to completion status. Interrupting the evaluation context cancels the parking task. The evaluation\ncontext defaults to the current thread if the host platform supports it, and can be redefined with `sp` or `ap`.\n","^7",198,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/?","^12","^H","^15",true],"^R",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nReturns a continuous flow evaluating `body` (in an implicit `do`) in a new evaluation context and producing values of\neach subsequent fork. Body evaluation can be forked by a continuous flow with `?<`. Evaluation and transfers are lazy,\ndriven by downstream sampling. Cancelling an `cp` process interrupts its root evaluation context.\n","^7",289,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/cp","^12","^H","^15",true],"^S",["^ ","^17",["^18",[[],["^1<"],["^1<","~$&","^19"]]],"^1:","In an `ap` block, evaluates each form sequentially and returns successive results.","^7",490,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/amb","^12","^H","^15",true],"^T",["^ ","^12","^H","^13","~$missionary.core/??","^6","missionary/core.cljc","^8",1,"^7",233,"^15",true,"^16",true,"^17",["^18",[["~$f"]]],"^1:","Alias for `?>`"],"^U",["^ ","^17",["^18",[["^1A"],["~$par","^1A"]]],"^1:","\nForks current evaluation context by given flow. Evaluation resumes whenever the flow transfers, result is returned or\nrethrown according to transfer status. Each transfer creates a new processing branch and defines a new evaluation\ncontext inherited from its parent. `par` is an optional positive number, defaulting to 1, defining the maximal count\nof processing branches allowed to be run concurrently. Interrupting the parent evaluation context cancels the forking\nflow and interrupts all processing branches currently being run and those subsequently run. The evaluation context is\nundefined by default and can be defined with `ap`.\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(m/? (m/reduce conj (m/ap (inc (m/?> (m/seed [1 2 3]))))))\n#_=> [2 3 4]\n```\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(m/? (->> (m/ap\n            (let [x (m/?> 5 (m/seed [19 57 28 6 87]))]\n              (m/? (m/sleep x x))))\n       (m/reduce conj)))\n#_=> [6 19 28 57 87]    ;; in 87 ms\n```\n","^7",205,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/?>","^12","^H","^15",true],"^V",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nReturns a discrete flow evaluating `body` (in an implicit `do`) in a new evaluation context and producing values of each\nsubsequent fork. Body evaluation can be parked by a task with `?` and forked by a flow with `?>` and `?<`. Evaluation\nand transfers are eager, backpressured by downstream transfers. Cancelling an `ap` process interrupts its root\nevaluation context.\n","^7",301,"^8",1,"^6","missionary/core.cljc","^13","~$missionary.core/ap","^12","^H","^15",true]],"^13","^H","~:reader-aliases",["^ "],"~:op","^12","~:imports",["^ ","~$Zip","~$missionary.impl.Zip","~$Reactor","~$missionary.impl.Reactor","~$Mailbox","~$missionary.impl.Mailbox","~$Sequential","~$missionary.impl.Sequential","~$Dataflow","~$missionary.impl.Dataflow","~$Observe","~$missionary.impl.Observe","~$Sleep","~$missionary.impl.Sleep","~$Eduction","~$missionary.impl.Eduction","~$Buffer","~$missionary.impl.Buffer","~$Latest","~$missionary.impl.Latest","~$Reduce","~$missionary.impl.Reduce","~$RaceJoin","~$missionary.impl.RaceJoin","~$Rendezvous","~$missionary.impl.Rendezvous","~$Reductions","~$missionary.impl.Reductions","~$Sample","~$missionary.impl.Sample","~$Relieve","~$missionary.impl.Relieve","~$GroupBy","~$missionary.impl.GroupBy","~$Ambiguous","~$missionary.impl.Ambiguous","~$Never","~$missionary.impl.Never","~$Continuous","~$missionary.impl.Continuous","~$Seed","~$missionary.impl.Seed","~$Fiber","~$missionary.impl.Fiber","~$Semaphore","~$missionary.impl.Semaphore","~$Watch","~$missionary.impl.Watch"],"~:requires",["^ ","^1U","^1V","^20","^20","^2H","^2H","^1W","^1X","^1Z","^1Z","^2@","^2@","^1Y","^1Z","^1[","^20","^21","^22","^23","^24","^25","^26","^27","^28","^2T","^2T","^22","^22","^24","^24","^29","^2:","^2R","^2R","^E","^E","^2L","^2L","^28","^28","^2;","^2<","^2=","^2>","~$goog","^2Z","^2?","^2@","^2A","^2B","^2C","^2D","^2D","^2D","^1V","^1V","^2E","^2F","^2G","^2H","^26","^26","^2B","^2B","^2I","^2J","^1X","^1X","^2N","^2N","^2K","^2L","^2V","^2V","^2M","^2N","^2>","^2>","^2O","^2P","^2Q","^2R","^2X","^2X","^2J","^2J","^2S","^2T","^2:","^2:","^2P","^2P","^2U","^2V","^2<","^2<","^P","^P","^2F","^2F","^2W","^2X"],"~:seen",["^X",["~:require","~:require-macros"]],"~:uses",["^ ","^O","^P"],"^31",["^ ","^P","^P","^H","^H","^E","^E"],"~:form",["^18",["~$ns","^H",["^18",["~:refer-clojure","~:exclude",["^Z","^10","^Y","^["]]],["^18",["^30",["^P","~:refer",["^O"],"~:include-macros",true]]],["^18",["~:import",["^18",["~$missionary.impl","^2=","^2C","^2I","^2G","^2;","^2E","^1W","^2S","^1[","^2K","^2O","^2W","^23","^29","^2A","^21","^1Y","^2U","^2?","^25","^2M","^2Q","^27","^1U"]]]],["^18",["^31",["^H","^37",["^M","^V","^R","^S","^G","^J","~$!","~$?","^U","^L","^T","^I","^Q","^N","^K"]]]]]],"~:flags",["^ ","^30",["^X",[]],"^31",["^X",[]]],"~:js-deps",["^ "],"~:deps",["^2Z","^E","^P","^2>","^2D","^2J","^2H","^2<","^2F","^1X","^2T","^20","^2L","^2P","^2X","^24","^2:","^2B","^22","^1Z","^2V","^2@","^26","^2N","^2R","^28","^1V"]],"^12","^H","~:resource-id",["~:shadow.build.classpath/resource","missionary/core.cljc"],"~:compiled-at",1693922839966,"^1R",["^ ","^1U","^1V","^20","^20","^2H","^2H","^1W","^1X","^1Z","^1Z","^2@","^2@","^1Y","^1Z","^1[","^20","^21","^22","^23","^24","^25","^26","^H","^H","^27","^28","^2T","^2T","^22","^22","^24","^24","^29","^2:","^2R","^2R","^E","^E","^2L","^2L","^28","^28","^2;","^2<","^2=","^2>","^2Z","^2Z","^2?","^2@","^2A","^2B","^2C","^2D","^2D","^2D","^1V","^1V","^2E","^2F","^2G","^2H","^26","^26","^2B","^2B","^2I","^2J","^1X","^1X","^2N","^2N","^2K","^2L","^2V","^2V","^2M","^2N","^2>","^2>","^2O","^2P","^2Q","^2R","^2X","^2X","^2J","^2J","^2S","^2T","^2:","^2:","^2P","^2P","^2U","^2V","^2<","^2<","^P","^P","^2F","^2F","^2W","^2X"],"~:resource-name","missionary/core.cljc","~:warnings",[],"~:source","(ns missionary.core\n  (:refer-clojure :exclude [reduce reductions eduction group-by])\n  (:require [cloroutine.core :refer [cr] :include-macros true])\n  (:import (missionary.impl Reduce Reductions GroupBy Relieve Latest Sample Reactor Fiber Sequential Ambiguous\n                            Continuous Watch Observe Buffer Rendezvous Dataflow Mailbox Semaphore RaceJoin Sleep\n                            Never Seed Eduction Zip #?(:clj Thunk) #?(:clj Pub) #?(:clj Sub))\n           #?(:clj org.reactivestreams.Publisher))\n  #?(:cljs (:require-macros [missionary.core :refer [sp ap cp amb amb> amb= ! ? ?> ?< ?? ?! ?= holding reactor]])))\n\n\n(def\n  ^{:static true\n    :doc \"A `java.util.concurrent.Executor` optimized for blocking evaluation.\"}\n  blk #?(:clj Thunk/blk))\n\n\n(def\n  ^{:static true\n    :doc \"A `java.util.concurrent.Executor` optimized for non-blocking evaluation.\"}\n  cpu #?(:clj Thunk/cpu))\n\n\n(defn\n  ^{:static true\n    :arglists '([executor thunk])\n    :doc \"\nSame as `via`, except the expression to evaluate is provided as a zero-arity function on second argument.\n\nNot supported on clojurescript.\n\n```clojure\n(? (via-call blk read-line))\n;; reads a line from stdin and returns it\n```\n\"} via-call [e t]\n  (fn [s f]\n    #?(:clj (Thunk/run e t s f)\n       :cljs (throw (js/Error. \"Unsupported operation.\")))))\n\n\n(defmacro\n  ^{:arglists '([executor & body])\n    :doc \"\nReturns a task evaluating body (in an implicit `do`) on given `java.util.concurrent.Executor` and completing with its result.\n\nCancellation interrupts the evaluating thread.\n\nNot supported on clojurescript.\n\nExample :\n```clojure\n\n```\n\"} via [exec & body] `(via-call ~exec #(do ~@body)))\n\n\n(defn\n  ^{:static true\n    :arglists '([duration] [duration value])\n    :doc \"\nReturns a task completing with given value (nil if not provided) after given duration (in milliseconds).\n\nCancelling a sleep task makes it fail immediately.\n\nExample :\n```clojure\n(? (sleep 1000 42))\n#_=> 42               ;; 1 second later\n```\n\"} sleep\n  ([d] (sleep d nil))\n  ([d x] (fn [s f] (Sleep/run d x s f))))\n\n\n(defn\n  ^{:static true\n    :arglists '([f & tasks])\n    :doc \"\nReturns a task running given `tasks` concurrently.\n\nIf every task succeeds, `join` completes with the result of applying `f` to these results.\n\nIf any task fails, others are cancelled then `join` fails with this error.\n\nCancelling propagates to children tasks.\n\nExample :\n```clojure\n(? (join vector (sleep 1000 1) (sleep 1000 2)))\n#_=> [1 2]            ;; 1 second later\n```\n\"} join\n  ([c] (fn [s _] (s (c)) #(do)))\n  ([c & ts] (fn [s f] (RaceJoin/run false c ts s f))))\n\n\n(defn ^{:static true :no-doc true} race-failure [& errors]\n  (ex-info \"Race failure.\" {::errors errors}))\n\n\n(defn\n  ^{:static true\n    :arglists '([& tasks])\n    :doc \"\nReturns a task running given `tasks` concurrently.\n\nIf any task succeeds, others are cancelled then `race` completes with this result.\n\nIf every task fails, `race` fails.\n\nCancelling propagates to children tasks.\n\nExample :\n```clojure\n(? (race (sleep 1000 1) (sleep 2000 2)))\n#_=> 1                 ;; 1 second later\n```\n\"} race\n  ([] (fn [_ f] (f (race-failure)) #(do)))\n  ([& ts] (fn [s f] (RaceJoin/run true race-failure ts s f))))\n\n\n(defn\n  ^{:static true\n    :arglists '([task])\n    :doc \"\nReturns a task always succeeding with result of given `task` wrapped in a zero-argument function returning result if successful or throwing exception if failed.\n\"} attempt [task]\n  (fn [s _] (task (fn [x] (s #(-> x))) (fn [e] (s #(throw e))))))\n\n\n(defn\n  ^{:static true\n    :arglists '([task])\n    :doc \"\nReturns a task running given `task` completing with a zero-argument function and completing with the result of this function call.\n\"} absolve [task]\n  (fn [s f]\n    (task\n      (fn [t]\n        (try (s (t))\n             (catch #?(:clj Throwable\n                       :cljs :default) e\n               (f e)))) f)))\n\n\n(def\n  ^{:static true\n    :arglists '([task delay] [task delay value])\n    :doc \"\nReturns a task running given `task` and completing with its result if available within specified `delay` (in\nmilliseconds). Otherwise, input is cancelled and the process succeeds with `value`, or `nil` if not provided.\n\n```clojure\n(m/? (m/timeout (m/sleep 20 :a) 25 :b)) ;; :a after 20ms\n(m/? (m/timeout (m/sleep 20 :a) 15 :b)) ;; :b after 15ms\n(m/? (m/timeout (m/sleep 20 :a) 15))    ;; nil after 15ms\n```\n\"} timeout\n  (fn timeout\n    ([task delay] (timeout task delay nil))\n    ([task delay value]\n     (-> task\n       (attempt)\n       (race (sleep delay #(-> value)))\n       (absolve)))))\n\n\n(defn ^:no-doc check []\n  (Fiber/check (Fiber/current)))\n\n(defn ^:no-doc park [task]\n  (Fiber/park (Fiber/current) task))\n\n(defn ^:no-doc switch [flow]\n  (Fiber/swich (Fiber/current) flow))\n\n(defn ^:no-doc fork [par flow]\n  (assert (pos? par) \"Non-positive parallelism.\")\n  (Fiber/fork (Fiber/current) par flow))\n\n(defn ^:no-doc unpark []\n  (Fiber/unpark (Fiber/current)))\n\n(defn ^:no-doc sp-run [c s f]\n  (Sequential/run c s f))\n\n(defn ^:no-doc ap-run [c n t]\n  (Ambiguous/run c n t))\n\n(defmacro ! \"\nThrows an instance of `missionary.Cancelled` if current evaluation context is interrupted, otherwise returns nil. The\nevaluation context defaults to the current thread if the host platform supports it, and can be redefined with `sp`,\n`ap`, or `cp`.\n\" [] `(check))\n\n\n(defmacro ? \"\nParks current evaluation context by given task. Evaluation resumes when the task completes, result is returned or\nrethrown according to completion status. Interrupting the evaluation context cancels the parking task. The evaluation\ncontext defaults to the current thread if the host platform supports it, and can be redefined with `sp` or `ap`.\n\" [task] `(park ~task))\n\n\n(defmacro ?> \"\nForks current evaluation context by given flow. Evaluation resumes whenever the flow transfers, result is returned or\nrethrown according to transfer status. Each transfer creates a new processing branch and defines a new evaluation\ncontext inherited from its parent. `par` is an optional positive number, defaulting to 1, defining the maximal count\nof processing branches allowed to be run concurrently. Interrupting the parent evaluation context cancels the forking\nflow and interrupts all processing branches currently being run and those subsequently run. The evaluation context is\nundefined by default and can be defined with `ap`.\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(m/? (m/reduce conj (m/ap (inc (m/?> (m/seed [1 2 3]))))))\n#_=> [2 3 4]\n```\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(m/? (->> (m/ap\n            (let [x (m/?> 5 (m/seed [19 57 28 6 87]))]\n              (m/? (m/sleep x x))))\n       (m/reduce conj)))\n#_=> [6 19 28 57 87]    ;; in 87 ms\n```\n\" ([flow] `(fork 1 ~flow))\n  ([par flow] `(fork ~par ~flow)))\n\n\n(defmacro ^{:deprecated true\n            :doc \"Alias for `?>`\"}\n  ?? [f] `(?> ~f))\n\n\n(defmacro ?< \"\nForks current evaluation context by given flow. Evaluation resumes whenever the flow transfers, result is returned or\nrethrown according to transfer status. Each transfer creates a new processing branch and defines a new evaluation\ncontext inherited from its parent. Concurrent processing branches are not allowed, and the current processing branch is\ninterrupted when the forking flow becomes ready to transfer again. Interrupting the parent evaluation context cancels\nthe forking flow and interrupts all processing branches currently being run and those subsequently run. The evaluation\ncontext is undefined by default and can be defined with `ap` or `cp`.\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(import missionary.Cancelled)\n\n(defn debounce [delay flow]\n  (m/ap (let [x (m/?< flow)]\n          (try (m/? (m/sleep delay x))\n               (catch Cancelled _ (m/amb))))))\n\n(m/? (->> (m/ap (let [n (m/amb 24 79 67 34 18 9 99 37)]\n                  (m/? (m/sleep n n))))\n       (debounce 50)\n       (m/reduce conj)))\n#_=> [24 79 9 37]\n```\n\" [flow] `(switch ~flow))\n\n\n(defmacro ^{:deprecated true\n            :doc \"Alias for `?<`\"}\n  ?! [f] `(?< ~f))\n\n\n(defmacro\n  ^{:arglists '([flow])\n    :deprecated true\n    :doc \"Alias for `(?> ##Inf flow)`\"}\n  ?= [flow] `(?> ##Inf ~flow))\n\n\n(defmacro\n  ^{:arglists '([& body])\n    :doc \"\nReturns a task evaluating `body` (in an implicit `do`) in a new evaluation context and completing its result. Body\nevaluation can be parked by a task with `?`. Cancelling a `sp` process interrupts its evaluation context.\n\"} sp [& body]\n  `(partial\n     (cr {park unpark}\n       ~@body) sp-run))\n\n(defn ^:no-doc cp* [cr] (Continuous/flow cr))\n\n(defmacro\n  ^{:arglists '([& body])\n    :doc \"\nReturns a continuous flow evaluating `body` (in an implicit `do`) in a new evaluation context and producing values of\neach subsequent fork. Body evaluation can be forked by a continuous flow with `?<`. Evaluation and transfers are lazy,\ndriven by downstream sampling. Cancelling an `cp` process interrupts its root evaluation context.\n\"} cp [& body]\n  `(cp*\n     (cr {switch unpark}\n       ~@body)))\n\n\n(defmacro\n  ^{:arglists '([& body])\n    :doc \"\nReturns a discrete flow evaluating `body` (in an implicit `do`) in a new evaluation context and producing values of each\nsubsequent fork. Body evaluation can be parked by a task with `?` and forked by a flow with `?>` and `?<`. Evaluation\nand transfers are eager, backpressured by downstream transfers. Cancelling an `ap` process interrupts its root\nevaluation context.\n\"} ap [& body]\n  `(partial\n     (cr {park unpark\n          fork unpark\n          switch unpark}\n       ~@body) ap-run))\n\n\n(defn\n  ^{:static true\n    :arglists '([task])\n    :doc \"\nInhibits cancellation signal of given `task`.\n\"} compel [task]\n  (fn [s f] (task s f) #(do)))\n\n\n(defn\n  ^{:static true\n    :arglists '([])\n    :doc \"\nCreates an instance of dataflow variable (aka single-assignment).\n\nA dataflow variable is a function implementing `assign` on 1-arity and `deref` on 2-arity (as task). `assign` immediately binds the variable to given value if not already bound and returns bound value. `deref` is a task completing with the value bound to the variable as soon as it's available.\n\nCancelling a `deref` task makes it fail immediately.\n```\n\"} dfv [] (Dataflow/make))\n\n\n(defn\n  ^{:static true\n    :arglists '([])\n    :doc \"\nCreates an instance of mailbox.\n\nA mailbox is a function implementing `post` on 1-arity and `fetch` on 2-arity (as task). `post` immediately pushes given value to mailbox and returns nil. `fetch` is a task pulling a value from mailbox as soon as it's non-empty and completing with this value.\n\nCancelling a `fetch` task makes it fail immediately.\n\nExample : an actor is a mailbox associated with a process consuming messages.\n```clojure\n(defn crash [^Throwable e]                                ;; let it crash philosophy\n  (.printStackTrace e)\n  (System/exit -1))\n\n(defn actor\n  ([init] (actor init crash))\n  ([init fail]\n   (let [self (mbx)]\n     ((sp\n        (loop [b init]\n          (recur (b self (? self)))))\n       nil fail)\n     self)))\n\n(def counter\n  (actor\n    ((fn beh [n]\n       (fn [self cust]\n         (cust n)\n         (beh (inc n)))) 0)))\n\n(counter prn)                                             ;; prints 0\n(counter prn)                                             ;; prints 1\n(counter prn)                                             ;; prints 2\n```\n\"} mbx [] (Mailbox/make))\n\n\n(defn\n  ^{:static true\n    :arglists '([])\n    :doc \"\nCreates an instance of synchronous rendez-vous.\n\nA synchronous rendez-vous is a function implementing `give` on its 1-arity and `take` on its 2-arity (as task). `give` takes a value to be transferred and returns a task completing with nil as soon as a taker is available. `take` is a task completing with transferred value as soon as a giver is available.\n\nCancelling `give` and `take` tasks makes them fail immediately.\n\nExample : producer / consumer stream communication\n```clojure\n(defn reducer [rf i take]\n  (sp\n    (loop [r i]\n      (let [x (? take)]\n        (if (identical? x take)\n          r (recur (rf r x)))))))\n\n(defn iterator [give xs]\n  (sp\n    (loop [xs (seq xs)]\n      (if-some [[x & xs] xs]\n        (do (? (give x))\n            (recur xs))\n        (? (give give))))))\n\n(def stream (rdv))\n\n(? (join {} (iterator stream (range 100)) (reducer + 0 stream)))      ;; returns 4950\n```\n\"} rdv [] (Rendezvous/make))\n\n\n(defn\n  ^{:static true\n    :arglists '([] [n])\n    :doc \"\nCreates a semaphore initialized with n tokens (1 if not provided, aka mutex).\n\nA semaphore is a function implementing `release` on 0-arity and `acquire` on 2-arity (as task). `release` immediately makes a token available and returns nil. `acquire` is a task completing with nil as soon as a token is available.\n\nCancelling an `acquire` task makes it fail immediately.\n\nExample : dining philosophers\n```clojure\n(defn phil [name f1 f2]\n  (sp\n    (while true\n      (prn name :thinking)\n      (? (sleep 500))\n      (holding f1\n        (holding f2\n          (prn name :eating)\n          (? (sleep 600)))))))\n\n(def forks (vec (repeatedly 5 sem)))\n\n(? (timeout 10000\n     (join vector\n       (phil \\\"descartes\\\" (forks 0) (forks 1))\n       (phil \\\"hume\\\"      (forks 1) (forks 2))\n       (phil \\\"plato\\\"     (forks 2) (forks 3))\n       (phil \\\"nietzsche\\\" (forks 3) (forks 4))\n       (phil \\\"kant\\\"      (forks 0) (forks 4)))))\n```\n\"} sem\n  ([] (sem 1))\n  ([n] (Semaphore/make n)))\n\n\n(defmacro\n  ^{:arglists '([semaphore & body])\n    :doc \"\n`acquire`s given `semaphore` and evaluates `body` (in an implicit `do`), ensuring `semaphore` is `release`d after evaluation.\n\"} holding [lock & body]\n  `(let [l# ~lock] (? l#) (try ~@body (finally (l#)))))\n\n\n(def never\n  ^{:static true\n    :doc \"\nA task never succeeding. Cancelling makes it fail immediately.\"}\n  (fn [_ f] (Never/run f)))\n\n\n(def\n  ^{:static true\n    :doc \"\nThe empty flow. Doesn't produce any value and terminates immediately. Cancelling has no effect.\n\nExample :\n```clojure\n(? (reduce conj none))\n#_=> []\n```\n\"} none (fn [_ t] (t) #(do)))\n\n\n(defn\n  ^{:static true\n    :arglists '([collection])\n    :doc \"\nReturns a discrete flow producing values from given `collection`. Cancelling before having reached the end makes the flow fail immediately.\n\"} seed [coll]\n  (fn [n t] (Seed/run coll n t)))\n\n(def ^{:deprecated true\n       :doc \"Alias for `seed`\"}\n  enumerate seed)\n\n\n(defmacro\n  ^{:arglists '([& forms])\n    :doc \"In an `ap` block, evaluates each form sequentially and returns successive results.\"}\n  amb\n  ([] `(?> none))\n  ([form] form)\n  ([form & forms]\n   (let [n (inc (count forms))]\n     `(case (?> (seed (range ~n)))\n        ~@(interleave (range) (cons form forms))))))\n\n\n(defmacro\n  ^{:arglists '([& forms])\n    :doc \"In an `ap` block, evaluates each form concurrently and returns results in order of availability.\"}\n  amb=\n  ([] `(?> none))\n  ([form] form)\n  ([form & forms]\n   (let [n (inc (count forms))]\n     `(case (?> ~n (seed (range ~n)))\n        ~@(interleave (range) (cons form forms))))))\n\n\n(defmacro\n  ^{:deprecated true\n    :arglists '([& forms])\n    :doc \"Alias for `amb`\"}\n  amb> [& forms] (cons `amb forms))\n\n\n(defn\n  ^{:static true\n    :arglists '([rf flow] [rf init flow])\n    :doc \"\nReturns a task reducing values produced by given discrete `flow` with `rf`, starting with `init` (or, if not provided, the result of calling `rf` with no argument).\n\nCancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (reduce + (seed (range 10))))\n#_=> 45\n```\n\"} reduce\n  ([rf flow] (fn [s f] (Reduce/run rf flow s f)))\n  ([rf i flow] (reduce (fn ([] i) ([r x] (rf r x))) flow)))\n\n(def ^{:deprecated true\n       :doc \"Alias for `reduce`\"}\n  aggregate reduce)\n\n\n(defn\n  ^{:static true\n    :arglists '([reference])\n    :doc \"\nReturns a continuous flow reflecting the current state of a reference type. `reference` must support `add-watch`,\n`remove-watch` and `deref`. On initialization, the process is ready to transfer. On transfer, the current state is\nreturned. Whenever the state of the reference changes and a transfer is not pending, the process becomes ready to\ntransfer again. Cancelling the process makes it fail immediately with an instance of `missionary.Cancelled` and\nterminates the process.\n\"} watch [r] (fn [n t] (Watch/run r n t)))\n\n\n(defn\n  ^{:static true\n    :arglists '([subject])\n    :doc \"\nReturns a discrete flow observing values produced by a non-backpressured subject. `subject` must be a function taking a\ncallback and returning a cleanup thunk. On initialization, the process calls the subject with a fresh callback. Passing\na value to the callback makes the process ready to transfer this value. Cancelling the process makes it fail immediately\nwith an instance of `missionary.Cancelled` and terminates the process. The cleanup thunk is called on termination. The\ncallback throws an `Error` if the process is cancelled or terminated, or if a transfer is pending.\n\"} observe [s] (fn [n t] (Observe/run s n t)))\n\n\n(def\n  ^{:static true\n    :arglists '([xf* flow])\n    :doc \"\nReturns a discrete flow running given discrete `flow` and transforming values with the composition of given transducers `xf*`.\n\nCancelling propagates to upstream flow. Early termination by the transducing stage (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (->> (seed (range 10))\n        (eduction (filter odd?) (mapcat range) (partition-all 4))\n        (reduce conj)))\n#_=> [[0 0 1 2] [0 1 2 3] [4 0 1 2] [3 4 5 6] [0 1 2 3] [4 5 6 7] [8]]\n```\n\"} eduction\n  (fn e\n    ([f] f)\n    ([x f] (fn [n t] (Eduction/run x f n t)))\n    ([x y & zs] (apply e (comp x y) zs))))\n\n(def ^{:deprecated true\n       :doc \"Alias for `eduction`\"}\n  transform eduction)\n\n\n(defn\n  ^{:static true\n    :arglists '([rf flow] [rf init flow])\n    :doc \"\nReturns a discrete flow running given discrete `flow` and emitting given `init` value (or, if not provided, the result of calling `rf` with no argument) followed by successive reductions (by rf) of upstream values with previously emitted value.\n\nCancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (->> [1 2 3 4 5]\n        (seed)\n        (reductions +)\n        (reduce conj)))\n#_=> [0 1 3 6 10 15]\n```\n\"} reductions\n  ([rf f] (fn [n t] (Reductions/run rf f n t)))\n  ([rf i f] (reductions (fn ([] i) ([r x] (rf r x))) f)))\n\n(def ^{:deprecated true\n       :doc \"Alias for `reductions`\"}\n  integrate reductions)\n\n\n(defn\n  ^{:static true\n    :arglists '([flow])\n    :doc \"\nReturns a `org.reactivestreams.Publisher` running given discrete `flow` on each subscription.\n\"} publisher [f]\n  #?(:clj (reify Publisher (subscribe [_ s] (Pub. f s)))\n     :cljs (throw (js/Error. \"Unsupported operation.\"))))\n\n\n(defn\n  ^{:static true\n    :arglists '([pub])\n    :doc \"\nReturns a discrete flow subscribing to given `org.reactivestreams.Publisher`.\n\"} subscribe [pub]\n  #?(:clj (fn [n t] (Sub. pub n t))\n     :cljs (throw (js/Error. \"Unsupported operation.\"))))\n\n\n(def\n  ^{:static true\n    :arglists '([rf flow])\n    :doc \"\nReturns a continuous flow producing values emitted by given discrete `flow`, relieving backpressure. When upstream is faster than downstream, overflowed values are successively reduced with given function `rf`.\n\nCancelling propagates to upstream. If `rf` throws, upstream `flow` is cancelled.\n\nExample :\n```clojure\n;; Delays each `input` value by `delay` milliseconds\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(? (->> (ap (let [n (?> (seed [24 79 67 34 18 9 99 37]))]\n              (? (sleep n n))))\n        (relieve +)\n        (delay-each 80)\n        (reduce conj)))\n#_=> [24 79 67 61 99 37]\n```\n\"} relieve (fn [rf f] (fn [n t] (Relieve/run rf f n t))))\n\n\n(defn\n  ^{:static true\n    :arglists '([capacity flow])\n    :doc \"\nReturns a discrete flow producing values emitted by given discrete `flow`, accumulating upstream overflow up to `capacity` items.\n\"} buffer [c f]\n  (assert (pos? c) \"Non-positive buffer capacity.\")\n  (Buffer/flow c f))\n\n\n(def\n  ^{:static true\n    :arglists '([f & flows])\n    :doc \"\nReturns a flow running an arbitrary number of flows concurrently. The process is ready to transfer when at least one\ninput is ready to transfer. On transfer, all ready inputs are transferred, the function is called with the latest\nvalue of each input and the result is returned. If an input emits consecutive values, all of them are transferred and\nonly the latest one is retained. Each input must be initially ready.\n\nInput failures and exceptions thrown by `f` cancel the process and propagate the error. The process terminates when all\ninputs are terminated. Cancelling the process cancels all inputs.\n\n```clojure\n(defn sleep-emit [delays]\n  (reductions {} 0\n    (ap (let [n (?> (seed delays))]\n          (? (sleep n n))))))\n\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(? (->> (latest vector\n          (sleep-emit [24 79 67 34])\n          (sleep-emit [86 12 37 93]))\n        (delay-each 50)\n        (reduce conj)))\n\n#_=> [[0 0] [24 0] [24 86] [79 12] [79 37] [67 37] [34 93]]\n```\n\"} latest (fn [c & fs] (fn [n t] (Latest/run c fs n t))))\n\n\n(def\n  ^{:static true\n    :arglists '([f sampled* sampler])\n    :doc \"\nReturns a flow running an arbitrary number of sampled flows concurrently with a sampler flow. The process is ready to\ntransfer when the sampler is ready to transfer. On transfer, all ready inputs are transferred, the function is called\nwith the latest value of each input and the result is returned. If a sampled input emits consecutive values, all of\nthem are transferred and only the latest one is retained. Each sampled input must be initially ready.\n\nWhen the sampler input terminates, all sampled inputs are cancelled. Input failures and exceptions thrown by `f` cancel\nthe process, and propagate the error. The process terminates when all input flows are terminated. Cancelling the process\ncancels the sampler input.\n\nExample :\n```clojure\n(defn sleep-emit [delays]\n  (ap (let [n (?> (seed delays))]\n        (? (sleep n n)))))\n\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(m/? (->> (m/sample vector\n            (m/reductions {} 0 (sleep-emit [24 79 67 34]))\n            (sleep-emit [86 12 37 93]))\n       (delay-each 50)\n       (m/reduce conj)))\n\n#_=> [[24 86] [24 12] [79 37] [67 93]]\n```\n\"} sample (fn [c f & fs] (fn [n t] (Sample/run c f fs n t))))\n\n\n(defn\n  ^{:static true\n    :arglists '([f & flows])\n    :doc \"\nReturns a discrete flow running given discrete `flows` concurrently and emitting the result of applying `f` to the set of first values emitted by each upstream flow, followed by the result of applying `f` to the set of second values and so on, until any upstream flow terminates, at which point the flow will cancel all other upstream flows and wait for their termination.\n\nCancelling propagates to every upstream flow. If any upstream flow fails or if `f` throws, the flow is cancelled.\n\nExample :\n```clojure\n(m/? (->> (m/zip vector\n                 (m/seed [1 2 3])\n                 (m/seed [:a :b :c]))\n          (m/reduce conj)))\n#_=> [[1 :a] [2 :b] [3 :c]]\n```\n\"} zip [c f & fs] (fn [n t] (Zip/run c (cons f fs) n t)))\n\n\n(defn\n  ^{:static true\n    :arglists '([kf >f])\n    :doc \"\nReturns a discrete flow running given discrete flow, calling given key function on each produced value, grouping values\naccording to keys returned by the function, and producing a key-group pair for each grouping found. A group is a flow\nconsuming values matching a key. Upstream values are dispatched in constant time to their group consumer.\n\nCancelling a group consumer makes it fail immediately. If a value is subsequently found for the same grouping, the\nkey-group pair is produced again, including in the special case where the consumer is cancelled while a transfer was\npending. Cancelling a group consumer has no effect when the main process is cancelled.\n\nIf upstream fails, or if the key function throws, then upstream is cancelled and flushed and the error is propagated\ndownstream.\n\nWhen the last upstream value is consumed, downstream terminates along with each active consumer and subsequent ones.\n\nConcurrent consumers on a single group are not allowed, attempting to do so will fail the latest consumer.\n\nExample :\n```clojure\n(def words [\\\"Air\\\" \\\"Bud\\\" \\\"Cup\\\" \\\"Awake\\\" \\\"Break\\\" \\\"Chunk\\\" \\\"Ant\\\" \\\"Big\\\" \\\"Check\\\"])\n(def groups\n  (m/ap (let [[k >x] (m/?= (m/group-by (juxt first count) (m/seed words)))]\n          [k (m/? (m/reduce conj >x))])))\n(m/? (m/reduce conj {} groups))\n#_=> {[\\\\C 3] [\\\"Cup\\\"],\n      [\\\\B 5] [\\\"Break\\\"],\n      [\\\\A 5] [\\\"Awake\\\"],\n      [\\\\B 3] [\\\"Bud\\\" \\\"Big\\\"],\n      [\\\\A 3] [\\\"Air\\\" \\\"Ant\\\"],\n      [\\\\C 5] [\\\"Chunk\\\" \\\"Check\\\"]}\n```\n\"} group-by [kf f] (fn [n t] (GroupBy/run kf f n t)))\n\n\n(def\n  ^{:static true\n    :arglists '([boot])\n    :doc \"\nExperimental. To be deprecated in favor of [lazy publishers](https://github.com/leonoel/missionary/issues/70)\n\"} reactor-call (fn [i] (fn [s f] (Reactor/run i s f))))\n\n\n(defmacro\n  ^{:arglists '([& body])\n    :doc \"\nCalls `reactor-call` with a function evaluating given `body` in an implicit `do`.\n\"} reactor [& body] `(reactor-call (fn [] ~@body)))\n\n\n(def\n  ^{:static true\n    :arglists '([flow])\n    :doc \"\nSpawns a discrete publisher from given flow, see `reactor-call`.\n\"} stream! (fn [f] (Reactor/publish f false)))\n\n\n(def\n  ^{:static true\n    :arglists '([flow])\n    :doc \"\nSpawns a continuous publisher from given flow, see `reactor-call`.\n\"} signal! (fn [f] (Reactor/publish f true)))\n","~:reader-features",["^X",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["missionary.core/via-call","e","t","s","f","js/Error","var_args","G__30161","missionary.core/sleep","d","missionary.core.sleep","x","missionary.impl.Sleep/run","G__30170","missionary.core/join","args-arr__5794__auto__","len__5769__auto__","i__5770__auto__","argseq__5795__auto__","cljs.core/IndexedSeq","seq30168","G__30169","cljs.core/first","cljs.core/next","self__5754__auto__","c","_","G__30174","ts","missionary.impl.RaceJoin/run","args__5775__auto__","argseq__5776__auto__","missionary.core/race-failure","seq30175","self__5755__auto__","cljs.core/seq","errors","cljs.core.ex_info","G__30178","missionary.core/race","seq30177","G__30179","missionary.core/attempt","task","G__30180","G__30181","G__30182","G__30183","missionary.core/absolve","G__30184","G__30185","e30186","G__30187","missionary.core/timeout","delay","missionary$core$timeout","value","missionary.core.race","missionary.core/check","missionary.impl.Fiber/current","missionary.core/park","missionary.core/switch","flow","missionary.core/fork","par","missionary.core/unpark","missionary.core/sp-run","missionary.impl.Sequential/run","missionary.core/ap-run","n","missionary.impl.Ambiguous/run","missionary.core/cp*","cr","missionary.impl.Continuous/flow","missionary.core/compel","missionary.core/dfv","missionary.impl.Dataflow/make","missionary.core/mbx","missionary.impl.Mailbox/make","missionary.core/rdv","missionary.impl.Rendezvous/make","G__30214","missionary.core/sem","missionary.core.sem","missionary.impl.Semaphore/make","missionary.core/never","missionary.impl.Never/run","missionary.core/none","missionary.core/seed","coll","missionary.impl.Seed/run","missionary.core/enumerate","G__30217","missionary.core/reduce","rf","missionary.impl.Reduce/run","i","missionary.core.reduce","r","missionary.core/aggregate","missionary.core/watch","missionary.impl.Watch/run","missionary.core/observe","missionary.impl.Observe/run","missionary.core/eduction","missionary.impl.Eduction/run","y","zs","cljs.core.apply","cljs.core.comp","missionary.core/transform","G__30219","missionary.core/reductions","missionary.impl.Reductions/run","missionary.core.reductions","missionary.core/integrate","missionary.core/publisher","missionary.core/subscribe","pub","missionary.core/relieve","missionary.impl.Relieve/run","missionary.core/buffer","missionary.impl.Buffer/flow","missionary.core/latest","fs","missionary.impl.Latest/run","missionary.core/sample","missionary.impl.Sample/run","missionary.core/zip","seq30220","G__30221","G__30222","missionary.impl.Zip/run","cljs.core/cons","missionary.core/group-by","kf","missionary.impl.GroupBy/run","missionary.core/reactor-call","missionary.impl.Reactor/run","missionary.core/stream!","missionary.impl.Reactor/publish","missionary.core/signal!"]],"~:used-vars",["^X",["~$missionary.impl.Sample/run","~$missionary.impl.Reactor/run","~$cljs.core/comp","~$missionary.impl.Zip/run","~$missionary.core/reductions","~$missionary.impl.Relieve/run","~$missionary.impl.Mailbox/make","~$missionary.core/ap-run","~$missionary.impl.Buffer/flow","~$missionary.impl.Reactor/publish","~$missionary.core/cp*","~$missionary.core/compel","~$missionary.core/reactor-call","~$cljs.core/IndexedSeq","~$missionary.core/seed","~$cljs.core/seq","~$cljs.core/apply","~$missionary.core/rdv","~$missionary.core/zip","~$missionary.impl.Eduction/run","~$missionary.core/sem","~$missionary.impl.Observe/run","~$missionary.core/switch","~$missionary.impl.Fiber/current","~$missionary.impl.Reduce/run","~$missionary.core/watch","~$missionary.core/dfv","~$missionary.impl.Latest/run","~$missionary.impl.Fiber/swich","~$missionary.core/sample","~$missionary.core/never","~$missionary.core/latest","~$missionary.core/aggregate","~$missionary.impl.Continuous/flow","~$missionary.core/reduce","~$missionary.core/race-failure","~$missionary.core/stream!","~$missionary.core/timeout","~$missionary.core/integrate","~$missionary.core/attempt","~$missionary.core/unpark","~$missionary.impl.Fiber/fork","~$missionary.core/absolve","~$missionary.impl.Semaphore/make","~$missionary.core/relieve","~$missionary.impl.Fiber/park","~$missionary.core/blk","~$missionary.core/fork","~$missionary.core/park","~$missionary.core/eduction","~$missionary.core/enumerate","~$missionary.impl.RaceJoin/run","~$missionary.impl.Fiber/unpark","~$missionary.core/cpu","~$missionary.core/none","~$missionary.core/sleep","~$missionary.core/subscribe","~$missionary.impl.GroupBy/run","~$cljs.core/ex-info","~$missionary.core/signal!","~$missionary.core/buffer","~$missionary.core/join","~$missionary.impl.Reductions/run","~$cljs.core/next","~$missionary.impl.Sequential/run","~$missionary.impl.Sleep/run","~$cljs.core/cons","~$missionary.impl.Rendezvous/make","~$missionary.impl.Seed/run","~$missionary.impl.Ambiguous/run","~$missionary.impl.Never/run","~$missionary.core/transform","~$missionary.core/via-call","~$missionary.core/mbx","~$missionary.core/publisher","~$cljs.core/first","~$missionary.core/check","~$missionary.core/race","~$missionary.impl.Dataflow/make","~$js/Error","~$missionary.core/group-by","~$missionary.core/observe","~$missionary.core/sp-run","~$missionary.impl.Watch/run","~$missionary.impl.Fiber/check"]]],"~:cache-keys",["~#cmap",[["^3?","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^X",[]],"~:deps-syms",["^2Z","~$goog.dom.HtmlElement"]]],["^3?","missionary/Cancelled.js"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$clojure.string","~$goog.string"]]],["^3?","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cljs/env.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^3?","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^5T"]]],["^3?","cljs/analyzer/impl/namespaces.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","missionary/impl/Semaphore.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$missionary.Cancelled"]]],["^3?","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U"]]],["^3?","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","missionary/impl/Reactor.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","missionary/core.cljc"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^P","^2>","^2D","^2J","^2H","^2<","^2F","^1X","^2T","^20","^2L","^2P","^2X","^24","^2:","^2B","^22","^1Z","^2V","^2@","^26","^2N","^2R","^28","^1V"]]],["^3?","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$cljs.tools.reader.impl.errors","~$cljs.tools.reader.reader-types","~$cljs.tools.reader.impl.utils","~$cljs.tools.reader.impl.commons","~$cljs.tools.reader","^5P","~$goog.string.StringBuffer"]]],["^3?","missionary/impl/Seed.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","missionary/impl/RaceJoin.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^62","^63","^64","^61","^5Q","^5P","^66"]]],["^3?","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cloroutine/core.cljc"],["178f3a4f51830ad87c5f6a0f0bef14aa6108844d","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$cloroutine.impl"]]],["^3?","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U"]]],"~:SHADOW-TIMESTAMP",[1677656185000,1677656185000,1674331854000],["^3?","missionary/impl/Sequential.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^2T","^60"]]],["^3?","missionary/impl/Ambiguous.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^2T","^60"]]],["^3?","missionary/impl/Watch.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U","~$goog.reflect"]]],["^3?","missionary/impl/Eduction.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U","~$goog.fs.blob","^5V","~$goog.html.SafeScript","~$goog.html.trustedtypes","^5X","^5Y","^5Z","^5["]]],["^3?","missionary/impl/Latest.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$missionary.impl.Heap"]]],["^3?","missionary/impl/Sample.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","cljs/analyzer/passes/and_or.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$cljs.analyzer.passes"]]],["^3?","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","missionary/impl/Relieve.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","missionary/impl/GroupBy.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","missionary/impl/Zip.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5Z","~$goog.html.SafeUrl","^5[","^5U","^5T"]]],["^3?","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^6;","~$goog.html.SafeStyle","^6?","^5W","~$goog.html.uncheckedconversions","^5Z","^5T"]]],["^3?","missionary/impl/Buffer.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","cljs/analyzer/passes.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5Z","^5X","^5Y","^6;","^6C","~$goog.html.SafeStyleSheet","^6?","~$goog.dom.TagName","^5W","^5[","^5U","~$goog.labs.userAgent.browser","^5Q","^5R","^5T","~$goog.dom.tags","^6<"]]],["^3?","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5R"]]],["^3?","missionary/impl/Continuous.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^2T","^60"]]],["^3?","missionary/impl/Reduce.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cljs/reader.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^5R","^65","~$cljs.tools.reader.edn","^66"]]],["^3?","missionary/impl/Dataflow.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","missionary/impl/Mailbox.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^3?","cljs/tagged_literals.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$cljs.reader"]]],["^3?","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5Q","^5U","~$goog.collections.maps","^5P","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^3?","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cloroutine/impl.cljc"],["178f3a4f51830ad87c5f6a0f0bef14aa6108844d","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$cljs.analyzer","~$cljs.env"]]],["^3?","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","missionary/impl/Observe.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",[]]],["^3?","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5Q","^5R"]]],["^3?","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^62","^5O","~$cljs.tools.reader.impl.inspect"]]],["^3?","missionary/impl/Rendezvous.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^5P","^66"]]],["^3?","missionary/impl/Reductions.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","~$goog.dom.safe","^6D","^5Z","^5T"]]],["^3?","missionary/impl/Sleep.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]],["^3?","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","~$goog.labs.userAgent","^5T"]]],["^3?","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^63","^5P","^66"]]],["^3?","missionary/impl/Heap.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","missionary/impl/Fiber.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U","^6B","^6;","^6C","^6E","^6?","^5W","^5Z","^5T","^5X"]]],["^3?","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^61","^62","^63"]]],["^3?","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z"]]],["^3?","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","~$goog.math.Long","~$goog.math.Integer","^5P","^5R","^5Q","~$goog.Uri","^66"]]],["^3?","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5Z","^5[","^6<","^5U"]]],["^3?","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5Z","^6C","^5[","^5R","^5U","^5T"]]],["^3?","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^69"]]],["^3?","clojure/set.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U","^5P"]]],["^3?","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^5U","^5["]]],["^3?","cljs/analyzer.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","~$cljs.analyzer.impl","~$cljs.analyzer.impl.namespaces","~$cljs.analyzer.passes.and-or","^6S","^6L","~$cljs.tagged-literals","^65","^62","~$clojure.set","^5O","^5P"]]],["^3?","cljs/analyzer/impl.cljc"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E"]]],["^3?","missionary/impl/Never.cljs"],["b9821cff112a419498afb6330bfabf7bf58e36dd","^5J",["^ ","^5K",null,"^5L",["^X",[]],"^5M",["^2Z","^E","^60"]]]]],"~:clj-info",["^ ","jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1674331770000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1674331770000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/default_data_readers.clj",1674331770000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/reader.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.analyzer/1.1.1/tools.analyzer-1.1.1.jar!/clojure/tools/analyzer/utils.clj",1691052514000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/macros.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1674331770000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/missionary/missionary/b.28/missionary-b.28.jar!/missionary/core.cljc",1678884165000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader.clj",1674331770000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/cloroutine/cloroutine/11/cloroutine-11.jar!/cloroutine/impl.cljc",1678884165000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.analyzer/1.1.1/tools.analyzer-1.1.1.jar!/clojure/tools/analyzer/ast.clj",1691052514000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env/macros.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.analyzer.jvm/1.2.3/tools.analyzer.jvm-1.2.3.jar!/clojure/tools/analyzer/jvm/utils.clj",1691052514000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1674331770000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/reflect.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1669480727000,"jar:file:/Users/bariscanates/.m2/repository/cloroutine/cloroutine/11/cloroutine-11.jar!/cloroutine/core.cljc",1678884165000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.analyzer/1.1.1/tools.analyzer-1.1.1.jar!/clojure/tools/analyzer/env.clj",1691052514000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1674331854000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.analyzer/1.1.1/tools.analyzer-1.1.1.jar!/clojure/tools/analyzer.clj",1691052514000,"jar:file:/Users/bariscanates/.m2/repository/org/clojure/tools.analyzer.jvm/1.2.3/tools.analyzer.jvm-1.2.3.jar!/clojure/tools/analyzer/jvm.clj",1691052514000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","missionary/core.cljc","^7",1,"^8",5,"^9",1,"^:",20],"^;",["^ ","^<","^=","^>","^?","^@","^A","^B","^C","^D","^E"],"^F",["^ ","^G","^H","^I","^H","^J","^H","~$!","^H","^K","^H","^L","^H","^M","^H","^N","^H","^O","^P","^Q","^H","~$?","^H","^R","^H","^S","^H","^T","^H","^U","^H","^V","^H"],"^W",["^X",["^Y","^Z","^[","^10"]],"^11",["^ ","^G",["^ ","^12","^H","^13","^14","^6","missionary/core.cljc","^8",1,"^7",514,"^15",true,"^16",true,"^17",["^18",[["~$&","^19"]]],"^1:","Alias for `amb`"],"^I",["^ ","^12","^H","^13","^1;","^6","missionary/core.cljc","^8",1,"^7",265,"^15",true,"^16",true,"^17",["^18",[["~$f"]]],"^1:","Alias for `?<`"],"^J",["^ ","^17",["^18",[[],["^1<"],["^1<","~$&","^19"]]],"^1:","In an `ap` block, evaluates each form concurrently and returns results in order of availability.","^7",502,"^8",1,"^6","missionary/core.cljc","^13","^1=","^12","^H","^15",true],"~$!",["^ ","^17",["^18",[[]]],"^1:","\nThrows an instance of `missionary.Cancelled` if current evaluation context is interrupted, otherwise returns nil. The\nevaluation context defaults to the current thread if the host platform supports it, and can be redefined with `sp`,\n`ap`, or `cp`.\n","^7",191,"^8",1,"^6","missionary/core.cljc","^13","^1>","^12","^H","^15",true],"^K",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nCalls `reactor-call` with a function evaluating given `body` in an implicit `do`.\n","^7",800,"^8",1,"^6","missionary/core.cljc","^13","^1@","^12","^H","^15",true],"^L",["^ ","^17",["^18",[["^1A"]]],"^1:","\nForks current evaluation context by given flow. Evaluation resumes whenever the flow transfers, result is returned or\nrethrown according to transfer status. Each transfer creates a new processing branch and defines a new evaluation\ncontext inherited from its parent. Concurrent processing branches are not allowed, and the current processing branch is\ninterrupted when the forking flow becomes ready to transfer again. Interrupting the parent evaluation context cancels\nthe forking flow and interrupts all processing branches currently being run and those subsequently run. The evaluation\ncontext is undefined by default and can be defined with `ap` or `cp`.\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(import missionary.Cancelled)\n\n(defn debounce [delay flow]\n  (m/ap (let [x (m/?< flow)]\n          (try (m/? (m/sleep delay x))\n               (catch Cancelled _ (m/amb))))))\n\n(m/? (->> (m/ap (let [n (m/amb 24 79 67 34 18 9 99 37)]\n                  (m/? (m/sleep n n))))\n       (debounce 50)\n       (m/reduce conj)))\n#_=> [24 79 9 37]\n```\n","^7",238,"^8",1,"^6","missionary/core.cljc","^13","^1B","^12","^H","^15",true],"^M",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nReturns a task evaluating `body` (in an implicit `do`) in a new evaluation context and completing its result. Body\nevaluation can be parked by a task with `?`. Cancelling a `sp` process interrupts its evaluation context.\n","^7",277,"^8",1,"^6","missionary/core.cljc","^13","^1C","^12","^H","^15",true],"^N",["^ ","^17",["^18",[["^1D","~$&","^1?"]]],"^1:","\n`acquire`s given `semaphore` and evaluates `body` (in an implicit `do`), ensuring `semaphore` is `release`d after evaluation.\n","^7",449,"^8",1,"^6","missionary/core.cljc","^13","^1E","^12","^H","^15",true],"^1F",["^ ","^17",["^18",[["^1G","~$&","^1?"]]],"^1:","\nReturns a task evaluating body (in an implicit `do`) on given `java.util.concurrent.Executor` and completing with its result.\n\nCancellation interrupts the evaluating thread.\n\nNot supported on clojurescript.\n\nExample :\n```clojure\n\n```\n","^7",41,"^8",1,"^6","missionary/core.cljc","^13","^1H","^12","^H","^15",true],"^Q",["^ ","^12","^H","^13","^1I","^6","missionary/core.cljc","^8",1,"^7",270,"^15",true,"^16",true,"^17",["^18",[["^1A"]]],"^1:","Alias for `(?> ##Inf flow)`"],"~$?",["^ ","^17",["^18",[["^1J"]]],"^1:","\nParks current evaluation context by given task. Evaluation resumes when the task completes, result is returned or\nrethrown according to completion status. Interrupting the evaluation context cancels the parking task. The evaluation\ncontext defaults to the current thread if the host platform supports it, and can be redefined with `sp` or `ap`.\n","^7",198,"^8",1,"^6","missionary/core.cljc","^13","^1K","^12","^H","^15",true],"^R",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nReturns a continuous flow evaluating `body` (in an implicit `do`) in a new evaluation context and producing values of\neach subsequent fork. Body evaluation can be forked by a continuous flow with `?<`. Evaluation and transfers are lazy,\ndriven by downstream sampling. Cancelling an `cp` process interrupts its root evaluation context.\n","^7",289,"^8",1,"^6","missionary/core.cljc","^13","^1L","^12","^H","^15",true],"^S",["^ ","^17",["^18",[[],["^1<"],["^1<","~$&","^19"]]],"^1:","In an `ap` block, evaluates each form sequentially and returns successive results.","^7",490,"^8",1,"^6","missionary/core.cljc","^13","^1M","^12","^H","^15",true],"^T",["^ ","^12","^H","^13","^1N","^6","missionary/core.cljc","^8",1,"^7",233,"^15",true,"^16",true,"^17",["^18",[["~$f"]]],"^1:","Alias for `?>`"],"^U",["^ ","^17",["^18",[["^1A"],["^1O","^1A"]]],"^1:","\nForks current evaluation context by given flow. Evaluation resumes whenever the flow transfers, result is returned or\nrethrown according to transfer status. Each transfer creates a new processing branch and defines a new evaluation\ncontext inherited from its parent. `par` is an optional positive number, defaulting to 1, defining the maximal count\nof processing branches allowed to be run concurrently. Interrupting the parent evaluation context cancels the forking\nflow and interrupts all processing branches currently being run and those subsequently run. The evaluation context is\nundefined by default and can be defined with `ap`.\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(m/? (m/reduce conj (m/ap (inc (m/?> (m/seed [1 2 3]))))))\n#_=> [2 3 4]\n```\n\nExample :\n```clojure\n(require '[missionary.core :as m])\n(m/? (->> (m/ap\n            (let [x (m/?> 5 (m/seed [19 57 28 6 87]))]\n              (m/? (m/sleep x x))))\n       (m/reduce conj)))\n#_=> [6 19 28 57 87]    ;; in 87 ms\n```\n","^7",205,"^8",1,"^6","missionary/core.cljc","^13","^1P","^12","^H","^15",true],"^V",["^ ","^17",["^18",[["~$&","^1?"]]],"^1:","\nReturns a discrete flow evaluating `body` (in an implicit `do`) in a new evaluation context and producing values of each\nsubsequent fork. Body evaluation can be parked by a task with `?` and forked by a flow with `?>` and `?<`. Evaluation\nand transfers are eager, backpressured by downstream transfers. Cancelling an `ap` process interrupts its root\nevaluation context.\n","^7",301,"^8",1,"^6","missionary/core.cljc","^13","^1Q","^12","^H","^15",true]],"^13","^H","^1R",["^ "],"^1T",["^ ","^1U","^1V","^1W","^1X","^1Y","^1Z","^1[","^20","^21","^22","^23","^24","^25","^26","^27","^28","^29","^2:","^2;","^2<","^2=","^2>","^2?","^2@","^2A","^2B","^2C","^2D","^2E","^2F","^2G","^2H","^2I","^2J","^2K","^2L","^2M","^2N","^2O","^2P","^2Q","^2R","^2S","^2T","^2U","^2V","^2W","^2X"],"^2Y",["^ ","^1U","^1V","^20","^20","^2H","^2H","^1W","^1X","^1Z","^1Z","^2@","^2@","^1Y","^1Z","^1[","^20","^21","^22","^23","^24","^25","^26","^27","^28","^2T","^2T","^22","^22","^24","^24","^29","^2:","^2R","^2R","^E","^E","^2L","^2L","^28","^28","^2;","^2<","^2=","^2>","^2Z","^2Z","^2?","^2@","^2A","^2B","^2C","^2D","^2D","^2D","^1V","^1V","^2E","^2F","^2G","^2H","^26","^26","^2B","^2B","^2I","^2J","^1X","^1X","^2N","^2N","^2K","^2L","^2V","^2V","^2M","^2N","^2>","^2>","^2O","^2P","^2Q","^2R","^2X","^2X","^2J","^2J","^2S","^2T","^2:","^2:","^2P","^2P","^2U","^2V","^2<","^2<","^P","^P","^2F","^2F","^2W","^2X"],"^2[",["^X",["^30","^31"]],"~:shadow/js-access-global",["^X",["Error"]],"^32",["^ ","^O","^P"],"~:defs",["^ ","^Y",["^ ","~:protocol-inline",null,"^5",["^ ","^6","missionary/core.cljc","^7",582,"^8",4,"^9",582,"^:",12,"~:static",true,"^17",["^18",["~$quote",["^18",[["~$xf*","^1A"]]]]],"^1:","\nReturns a discrete flow running given discrete `flow` and transforming values with the composition of given transducers `xf*`.\n\nCancelling propagates to upstream flow. Early termination by the transducing stage (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (->> (seed (range 10))\n        (eduction (filter odd?) (mapcat range) (partition-all 4))\n        (reduce conj)))\n#_=> [[0 0 1 2] [0 1 2 3] [4 0 1 2] [3 4 5 6] [0 1 2 3] [4 5 6 7] [8]]\n```\n"],"^13","^4P","^6","missionary/core.cljc","^:",12,"^8<",true,"~:method-params",["^18",[["~$f"],["~$x","~$f"],["~$x","~$y","~$zs"]]],"~:protocol-impl",null,"~:arglists-meta",["^18",[null,["^ ","^6","missionary/core.cljc","^7",569,"^8",16,"^9",569,"^:",28]]],"^8",1,"~:variadic?",true,"^7",567,"^9",582,"~:max-fixed-arity",2,"~:fn-var",true,"^17",["^18",["^8=",["^18",[["^8>","^1A"]]]]],"^1:","\nReturns a discrete flow running given discrete `flow` and transforming values with the composition of given transducers `xf*`.\n\nCancelling propagates to upstream flow. Early termination by the transducing stage (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (->> (seed (range 10))\n        (eduction (filter odd?) (mapcat range) (partition-all 4))\n        (reduce conj)))\n#_=> [[0 0 1 2] [0 1 2 3] [4 0 1 2] [3 4 5 6] [0 1 2 3] [4 5 6 7] [8]]\n```\n"],"~$race-failure",["^ ","~:no-doc",true,"^8;",null,"^5",["^ ","^8G",true,"^6","missionary/core.cljc","^:",48,"^8<",true,"~:top-fn",["^ ","^8C",true,"~:fixed-arity",0,"^8D",0,"^8?",[["^18",["~$errors"]]],"^17",["^18",[["~$&","^8J"]]],"^8B",["^18",[null]]],"^8",36,"^7",97,"^9",97,"^17",["^18",["^8=",["^18",[["~$&","^8J"]]]]]],"^13","^4B","^6","missionary/core.cljc","^:",48,"^8<",true,"^8H",["^ ","^8C",true,"^8I",0,"^8D",0,"^8?",[["^18",["^8J"]]],"^17",["^18",[["~$&","^8J"]]],"^8B",["^18",[null]]],"^8?",[["^18",["^8J"]]],"^8A",null,"^8I",0,"^8B",["^18",[null]],"^8",1,"^8C",true,"~:methods",[["^ ","^8I",0,"^8C",true,"~:tag","~$any"]],"^7",97,"~:ret-tag","^8M","^9",97,"^8D",0,"^8E",true,"^17",["^18",[["~$&","^8J"]]]],"^Z",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",10,"^8<",true,"^8H",["^ ","^8C",false,"^8I",3,"^8D",3,"^8?",[["~$rf","^1A"],["^8O","~$i","^1A"]],"^17",["^18",[["^8O","^1A"],["^8O","~$i","^1A"]]],"^8B",["^18",[null,null]]],"^8",4,"^7",534,"^9",534,"^17",["^18",["^8=",["^18",[["^8O","^1A"],["^8O","~$i","^1A"]]]]],"^1:","\nReturns a task reducing values produced by given discrete `flow` with `rf`, starting with `init` (or, if not provided, the result of calling `rf` with no argument).\n\nCancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (reduce + (seed (range 10))))\n#_=> 45\n```\n"],"^13","^4A","^6","missionary/core.cljc","^:",10,"^8<",true,"^8H",["^ ","^8C",false,"^8I",3,"^8D",3,"^8?",[["^8O","^1A"],["^8O","~$i","^1A"]],"^17",["^18",[["^8O","^1A"],["^8O","~$i","^1A"]]],"^8B",["^18",[null,null]]],"^8?",[["^8O","^1A"],["^8O","~$i","^1A"]],"^8A",null,"^8I",3,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^8K",[["^ ","^8I",2,"^8C",false,"^8L","~$function"],["^ ","^8I",3,"^8C",false,"^8L","^8P"]],"^7",521,"^9",534,"^8D",3,"^8E",true,"^17",["^18",[["^8O","^1A"],["^8O","~$i","^1A"]]],"^1:","\nReturns a task reducing values produced by given discrete `flow` with `rf`, starting with `init` (or, if not provided, the result of calling `rf` with no argument).\n\nCancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (reduce + (seed (range 10))))\n#_=> 45\n```\n"],"~$stream!",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",812,"^8",4,"^9",812,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["^1A"]]]]],"^1:","\nSpawns a discrete publisher from given flow, see `reactor-call`.\n"],"^13","^4C","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["~$f"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",809,"^8",16,"^9",809,"^:",24]]],"^8",1,"^8C",false,"^7",807,"^8N","~$missionary.impl.Reactor/Publisher","^9",812,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1A"]]]]],"^1:","\nSpawns a discrete publisher from given flow, see `reactor-call`.\n"],"~$timeout",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",159,"^8",4,"^9",159,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["^1J","~$delay"],["^1J","^8T","~$value"]]]]],"^1:","\nReturns a task running given `task` and completing with its result if available within specified `delay` (in\nmilliseconds). Otherwise, input is cancelled and the process succeeds with `value`, or `nil` if not provided.\n\n```clojure\n(m/? (m/timeout (m/sleep 20 :a) 25 :b)) ;; :a after 20ms\n(m/? (m/timeout (m/sleep 20 :a) 15 :b)) ;; :b after 15ms\n(m/? (m/timeout (m/sleep 20 :a) 15))    ;; nil after 15ms\n```\n"],"^13","^4D","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["^1J","^8T"],["^1J","^8T","^8U"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",149,"^8",16,"^9",149,"^:",49]]],"^8",1,"^8C",false,"^7",147,"^9",159,"^8D",3,"^8E",true,"^17",["^18",["^8=",["^18",[["^1J","^8T"],["^1J","^8T","^8U"]]]]],"^1:","\nReturns a task running given `task` and completing with its result if available within specified `delay` (in\nmilliseconds). Otherwise, input is cancelled and the process succeeds with `value`, or `nil` if not provided.\n\n```clojure\n(m/? (m/timeout (m/sleep 20 :a) 25 :b)) ;; :a after 20ms\n(m/? (m/timeout (m/sleep 20 :a) 15 :b)) ;; :b after 15ms\n(m/? (m/timeout (m/sleep 20 :a) 15))    ;; nil after 15ms\n```\n"],"~$blk",["^ ","^5",["^ ","^6","missionary/core.cljc","^7",14,"^8",3,"^9",14,"^:",6,"^8<",true,"^1:","A `java.util.concurrent.Executor` optimized for blocking evaluation."],"^13","^4M","^6","missionary/core.cljc","^:",6,"^8<",true,"^8",1,"^7",11,"^9",14,"^1:","A `java.util.concurrent.Executor` optimized for blocking evaluation."],"~$signal!",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",820,"^8",4,"^9",820,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["^1A"]]]]],"^1:","\nSpawns a continuous publisher from given flow, see `reactor-call`.\n"],"^13","^4Z","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["~$f"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",817,"^8",16,"^9",817,"^:",24]]],"^8",1,"^8C",false,"^7",815,"^8N","^8R","^9",820,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1A"]]]]],"^1:","\nSpawns a continuous publisher from given flow, see `reactor-call`.\n"],"~$aggregate",["^ ","^5",["^ ","^6","missionary/core.cljc","^7",540,"^8",3,"^9",540,"^:",12,"^16",true,"^1:","Alias for `reduce`"],"^13","^4?","^6","missionary/core.cljc","^:",12,"^8",1,"^7",538,"^16",true,"^9",540,"^1:","Alias for `reduce`"],"~$enumerate",["^ ","^5",["^ ","^6","missionary/core.cljc","^7",487,"^8",3,"^9",487,"^:",12,"^16",true,"^1:","Alias for `seed`"],"^13","^4Q","^6","missionary/core.cljc","^:",12,"^8",1,"^7",485,"^16",true,"^9",487,"^1:","Alias for `seed`"],"~$fork",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",178,"^8",16,"^9",178,"^:",20,"^8G",true,"^17",["^18",["^8=",["^18",[["^1O","^1A"]]]]]],"^13","^4N","^6","missionary/core.cljc","^:",20,"^8?",["^18",[["^1O","^1A"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",178,"^8N","^8M","^9",178,"^8D",2,"^8E",true,"^17",["^18",["^8=",["^18",[["^1O","^1A"]]]]]],"~$park",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",172,"^8",16,"^9",172,"^:",20,"^8G",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]]],"^13","^4O","^6","missionary/core.cljc","^:",20,"^8?",["^18",[["^1J"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",172,"^8N","^8M","^9",172,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]]],"~$attempt",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",128,"^8",4,"^9",128,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]],"^1:","\nReturns a task always succeeding with result of given `task` wrapped in a zero-argument function returning result if successful or throwing exception if failed.\n"],"^13","^4F","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["^1J"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",123,"^8N","^8P","^9",128,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]],"^1:","\nReturns a task always succeeding with result of given `task` wrapped in a zero-argument function returning result if successful or throwing exception if failed.\n"],"~$integrate",["^ ","^5",["^ ","^6","missionary/core.cljc","^7",615,"^8",3,"^9",615,"^:",12,"^16",true,"^1:","Alias for `reductions`"],"^13","^4E","^6","missionary/core.cljc","^:",12,"^8",1,"^7",613,"^16",true,"^9",615,"^1:","Alias for `reductions`"],"~$subscribe",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",633,"^8",4,"^9",633,"^:",13,"^8<",true,"^17",["^18",["^8=",["^18",[["~$pub"]]]]],"^1:","\nReturns a discrete flow subscribing to given `org.reactivestreams.Publisher`.\n"],"^13","^4W","^6","missionary/core.cljc","^:",13,"^8<",true,"^8?",["^18",[["^93"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",628,"^8N","~$ignore","^9",633,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^93"]]]]],"^1:","\nReturns a discrete flow subscribing to given `org.reactivestreams.Publisher`.\n"],"~$absolve",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",137,"^8",4,"^9",137,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]],"^1:","\nReturns a task running given `task` completing with a zero-argument function and completing with the result of this function call.\n"],"^13","^4I","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["^1J"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",132,"^8N","^8P","^9",137,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]],"^1:","\nReturns a task running given `task` completing with a zero-argument function and completing with the result of this function call.\n"],"~$relieve",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",659,"^8",4,"^9",659,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["^8O","^1A"]]]]],"^1:","\nReturns a continuous flow producing values emitted by given discrete `flow`, relieving backpressure. When upstream is faster than downstream, overflowed values are successively reduced with given function `rf`.\n\nCancelling propagates to upstream. If `rf` throws, upstream `flow` is cancelled.\n\nExample :\n```clojure\n;; Delays each `input` value by `delay` milliseconds\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(? (->> (ap (let [n (?> (seed [24 79 67 34 18 9 99 37]))]\n              (? (sleep n n))))\n        (relieve +)\n        (delay-each 80)\n        (reduce conj)))\n#_=> [24 79 67 61 99 37]\n```\n"],"^13","^4K","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["^8O","~$f"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",640,"^8",16,"^9",640,"^:",27]]],"^8",1,"^8C",false,"^7",638,"^8N","^8P","^9",659,"^8D",2,"^8E",true,"^17",["^18",["^8=",["^18",[["^8O","^1A"]]]]],"^1:","\nReturns a continuous flow producing values emitted by given discrete `flow`, relieving backpressure. When upstream is faster than downstream, overflowed values are successively reduced with given function `rf`.\n\nCancelling propagates to upstream. If `rf` throws, upstream `flow` is cancelled.\n\nExample :\n```clojure\n;; Delays each `input` value by `delay` milliseconds\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(? (->> (ap (let [n (?> (seed [24 79 67 34 18 9 99 37]))]\n              (? (sleep n n))))\n        (relieve +)\n        (delay-each 80)\n        (reduce conj)))\n#_=> [24 79 67 61 99 37]\n```\n"],"~$sleep",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",9,"^8<",true,"^8H",["^ ","^8C",false,"^8I",2,"^8D",2,"^8?",[["~$d"],["~$d","~$x"]],"^17",["^18",[["~$d"],["~$d","~$x"]]],"^8B",["^18",[null,null]]],"^8",4,"^7",70,"^9",70,"^17",["^18",["^8=",["^18",[["~$d"],["~$d","~$x"]]]]],"^1:","\nReturns a task completing with given value (nil if not provided) after given duration (in milliseconds).\n\nCancelling a sleep task makes it fail immediately.\n\nExample :\n```clojure\n(? (sleep 1000 42))\n#_=> 42               ;; 1 second later\n```\n"],"^13","^4V","^6","missionary/core.cljc","^:",9,"^8<",true,"^8H",["^ ","^8C",false,"^8I",2,"^8D",2,"^8?",[["~$d"],["~$d","~$x"]],"^17",["^18",[["~$d"],["~$d","~$x"]]],"^8B",["^18",[null,null]]],"^8?",[["~$d"],["~$d","~$x"]],"^8A",null,"^8I",2,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^8K",[["^ ","^8I",1,"^8C",false,"^8L","^8M"],["^ ","^8I",2,"^8C",false,"^8L","^8P"]],"^7",57,"^9",70,"^8D",2,"^8E",true,"^17",["^18",[["~$d"],["~$d","~$x"]]],"^1:","\nReturns a task completing with given value (nil if not provided) after given duration (in milliseconds).\n\nCancelling a sleep task makes it fail immediately.\n\nExample :\n```clojure\n(? (sleep 1000 42))\n#_=> 42               ;; 1 second later\n```\n"],"~$unpark",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",182,"^8",16,"^9",182,"^:",22,"^8G",true,"^17",["^18",["^8=",["^18",[[]]]]]],"^13","^4G","^6","missionary/core.cljc","^:",22,"^8?",["^18",[[]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",182,"^8N","^8M","^9",182,"^8D",0,"^8E",true,"^17",["^18",["^8=",["^18",[[]]]]]],"~$switch",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",175,"^8",16,"^9",175,"^:",22,"^8G",true,"^17",["^18",["^8=",["^18",[["^1A"]]]]]],"^13","^45","^6","missionary/core.cljc","^:",22,"^8?",["^18",[["^1A"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",175,"^8N","^8M","^9",175,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1A"]]]]]],"~$join",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",8,"^8<",true,"^8H",["^ ","^8C",true,"^8I",1,"^8D",1,"^8?",[["~$c"]],"^17",["^18",[["~$c"],["~$c","~$&","~$ts"]]],"^8B",["^18",[null,null]]],"^8",4,"^7",92,"^9",92,"^17",["^18",["^8=",["^18",[["~$c"],["~$c","~$&","^9;"]]]]],"^1:","\nReturns a task running given `tasks` concurrently.\n\nIf every task succeeds, `join` completes with the result of applying `f` to these results.\n\nIf any task fails, others are cancelled then `join` fails with this error.\n\nCancelling propagates to children tasks.\n\nExample :\n```clojure\n(? (join vector (sleep 1000 1) (sleep 1000 2)))\n#_=> [1 2]            ;; 1 second later\n```\n"],"^13","^50","^6","missionary/core.cljc","^:",8,"^8<",true,"^8H",["^ ","^8C",true,"^8I",1,"^8D",1,"^8?",[["~$c"]],"^17",["^18",[["~$c"],["~$c","~$&","^9;"]]],"^8B",["^18",[null,null]]],"^8?",[["~$c"]],"^8A",null,"^8I",1,"^8B",["^18",[null,null]],"^8",1,"^8C",true,"^8K",[["^ ","^8I",1,"^8C",false,"^8L","^8P"],["^ ","^8I",1,"^8C",true,"^8L","^8P"]],"^7",75,"^9",92,"^8D",1,"^8E",true,"^17",["^18",[["~$c"],["~$c","~$&","^9;"]]],"^1:","\nReturns a task running given `tasks` concurrently.\n\nIf every task succeeds, `join` completes with the result of applying `f` to these results.\n\nIf any task fails, others are cancelled then `join` fails with this error.\n\nCancelling propagates to children tasks.\n\nExample :\n```clojure\n(? (join vector (sleep 1000 1) (sleep 1000 2)))\n#_=> [1 2]            ;; 1 second later\n```\n"],"~$cpu",["^ ","^5",["^ ","^6","missionary/core.cljc","^7",20,"^8",3,"^9",20,"^:",6,"^8<",true,"^1:","A `java.util.concurrent.Executor` optimized for non-blocking evaluation."],"^13","^4T","^6","missionary/core.cljc","^:",6,"^8<",true,"^8",1,"^7",17,"^9",20,"^1:","A `java.util.concurrent.Executor` optimized for non-blocking evaluation."],"~$none",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",474,"^8",4,"^9",474,"^:",8,"^8<",true,"^1:","\nThe empty flow. Doesn't produce any value and terminates immediately. Cancelling has no effect.\n\nExample :\n```clojure\n(? (reduce conj none))\n#_=> []\n```\n"],"^13","^4U","^6","missionary/core.cljc","^:",8,"^8<",true,"^8?",["^18",[["~$_","~$t"]]],"^8A",null,"^8B",["^18",[]],"^8",1,"^8C",false,"^7",464,"^8N","^8P","^9",474,"^8D",2,"^8E",true,"^17",null,"^1:","\nThe empty flow. Doesn't produce any value and terminates immediately. Cancelling has no effect.\n\nExample :\n```clojure\n(? (reduce conj none))\n#_=> []\n```\n"],"~$buffer",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",667,"^8",4,"^9",667,"^:",10,"^8<",true,"^17",["^18",["^8=",["^18",[["~$c","~$f"]]]]],"^1:","\nReturns a discrete flow producing values emitted by given discrete `flow`, accumulating upstream overflow up to `capacity` items.\n"],"^13","^4[","^6","missionary/core.cljc","^:",10,"^8<",true,"^8?",["^18",[["~$c","~$f"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",662,"^8N","^8M","^9",667,"^8D",2,"^8E",true,"^17",["^18",["^8=",["^18",[["~$c","~$f"]]]]],"^1:","\nReturns a discrete flow producing values emitted by given discrete `flow`, accumulating upstream overflow up to `capacity` items.\n"],"~$sp-run",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",185,"^8",16,"^9",185,"^:",22,"^8G",true,"^17",["^18",["^8=",["^18",[["~$c","~$s","~$f"]]]]]],"^13","^5E","^6","missionary/core.cljc","^:",22,"^8?",["^18",[["~$c","~$s","~$f"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",185,"^8N","~$missionary.impl.Sequential/Process","^9",185,"^8D",3,"^8E",true,"^17",["^18",["^8=",["^18",[["~$c","~$s","~$f"]]]]]],"~$via-call",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",35,"^8",4,"^9",35,"^:",12,"^8<",true,"^17",["^18",["^8=",["^18",[["~$e","~$t"]]]]],"^1:","\nSame as `via`, except the expression to evaluate is provided as a zero-arity function on second argument.\n\nNot supported on clojurescript.\n\n```clojure\n(? (via-call blk read-line))\n;; reads a line from stdin and returns it\n```\n"],"^13","^5;","^6","missionary/core.cljc","^:",12,"^8<",true,"^8?",["^18",[["~$e","~$t"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",23,"^8N","^8P","^9",35,"^8D",2,"^8E",true,"^17",["^18",["^8=",["^18",[["~$e","~$t"]]]]],"^1:","\nSame as `via`, except the expression to evaluate is provided as a zero-arity function on second argument.\n\nNot supported on clojurescript.\n\n```clojure\n(? (via-call blk read-line))\n;; reads a line from stdin and returns it\n```\n"],"~$transform",["^ ","^5",["^ ","^6","missionary/core.cljc","^7",590,"^8",3,"^9",590,"^:",12,"^16",true,"^1:","Alias for `eduction`"],"^13","^5:","^6","missionary/core.cljc","^:",12,"^8",1,"^7",588,"^16",true,"^9",590,"^1:","Alias for `eduction`"],"~$publisher",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",623,"^8",4,"^9",623,"^:",13,"^8<",true,"^17",["^18",["^8=",["^18",[["~$f"]]]]],"^1:","\nReturns a `org.reactivestreams.Publisher` running given discrete `flow` on each subscription.\n"],"^13","^5=","^6","missionary/core.cljc","^:",13,"^8<",true,"^8?",["^18",[["~$f"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",618,"^8N","^94","^9",623,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["~$f"]]]]],"^1:","\nReturns a `org.reactivestreams.Publisher` running given discrete `flow` on each subscription.\n"],"~$observe",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",564,"^8",4,"^9",564,"^:",11,"^8<",true,"^17",["^18",["^8=",["^18",[["~$s"]]]]],"^1:","\nReturns a discrete flow observing values produced by a non-backpressured subject. `subject` must be a function taking a\ncallback and returning a cleanup thunk. On initialization, the process calls the subject with a fresh callback. Passing\na value to the callback makes the process ready to transfer this value. Cancelling the process makes it fail immediately\nwith an instance of `missionary.Cancelled` and terminates the process. The cleanup thunk is called on termination. The\ncallback throws an `Error` if the process is cancelled or terminated, or if a transfer is pending.\n"],"^13","^5D","^6","missionary/core.cljc","^:",11,"^8<",true,"^8?",["^18",[["~$s"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",555,"^8N","^8P","^9",564,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["~$s"]]]]],"^1:","\nReturns a discrete flow observing values produced by a non-backpressured subject. `subject` must be a function taking a\ncallback and returning a cleanup thunk. On initialization, the process calls the subject with a fresh callback. Passing\na value to the callback makes the process ready to transfer this value. Cancelling the process makes it fail immediately\nwith an instance of `missionary.Cancelled` and terminates the process. The cleanup thunk is called on termination. The\ncallback throws an `Error` if the process is cancelled or terminated, or if a transfer is pending.\n"],"^[",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",789,"^8",4,"^9",789,"^:",12,"^8<",true,"^17",["^18",["^8=",["^18",[["~$kf","~$f"]]]]],"^1:","\nReturns a discrete flow running given discrete flow, calling given key function on each produced value, grouping values\naccording to keys returned by the function, and producing a key-group pair for each grouping found. A group is a flow\nconsuming values matching a key. Upstream values are dispatched in constant time to their group consumer.\n\nCancelling a group consumer makes it fail immediately. If a value is subsequently found for the same grouping, the\nkey-group pair is produced again, including in the special case where the consumer is cancelled while a transfer was\npending. Cancelling a group consumer has no effect when the main process is cancelled.\n\nIf upstream fails, or if the key function throws, then upstream is cancelled and flushed and the error is propagated\ndownstream.\n\nWhen the last upstream value is consumed, downstream terminates along with each active consumer and subsequent ones.\n\nConcurrent consumers on a single group are not allowed, attempting to do so will fail the latest consumer.\n\nExample :\n```clojure\n(def words [\"Air\" \"Bud\" \"Cup\" \"Awake\" \"Break\" \"Chunk\" \"Ant\" \"Big\" \"Check\"])\n(def groups\n  (m/ap (let [[k >x] (m/?= (m/group-by (juxt first count) (m/seed words)))]\n          [k (m/? (m/reduce conj >x))])))\n(m/? (m/reduce conj {} groups))\n#_=> {[\\C 3] [\"Cup\"],\n      [\\B 5] [\"Break\"],\n      [\\A 5] [\"Awake\"],\n      [\\B 3] [\"Bud\" \"Big\"],\n      [\\A 3] [\"Air\" \"Ant\"],\n      [\\C 5] [\"Chunk\" \"Check\"]}\n```\n"],"^13","^5C","^6","missionary/core.cljc","^:",12,"^8<",true,"^8?",["^18",[["^9E","~$f"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",756,"^8N","^8P","^9",789,"^8D",2,"^8E",true,"^17",["^18",["^8=",["^18",[["^9E","~$f"]]]]],"^1:","\nReturns a discrete flow running given discrete flow, calling given key function on each produced value, grouping values\naccording to keys returned by the function, and producing a key-group pair for each grouping found. A group is a flow\nconsuming values matching a key. Upstream values are dispatched in constant time to their group consumer.\n\nCancelling a group consumer makes it fail immediately. If a value is subsequently found for the same grouping, the\nkey-group pair is produced again, including in the special case where the consumer is cancelled while a transfer was\npending. Cancelling a group consumer has no effect when the main process is cancelled.\n\nIf upstream fails, or if the key function throws, then upstream is cancelled and flushed and the error is propagated\ndownstream.\n\nWhen the last upstream value is consumed, downstream terminates along with each active consumer and subsequent ones.\n\nConcurrent consumers on a single group are not allowed, attempting to do so will fail the latest consumer.\n\nExample :\n```clojure\n(def words [\"Air\" \"Bud\" \"Cup\" \"Awake\" \"Break\" \"Chunk\" \"Ant\" \"Big\" \"Check\"])\n(def groups\n  (m/ap (let [[k >x] (m/?= (m/group-by (juxt first count) (m/seed words)))]\n          [k (m/? (m/reduce conj >x))])))\n(m/? (m/reduce conj {} groups))\n#_=> {[\\C 3] [\"Cup\"],\n      [\\B 5] [\"Break\"],\n      [\\A 5] [\"Awake\"],\n      [\\B 3] [\"Bud\" \"Big\"],\n      [\\A 3] [\"Air\" \"Ant\"],\n      [\\C 5] [\"Chunk\" \"Check\"]}\n```\n"],"~$check",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",169,"^8",16,"^9",169,"^:",21,"^8G",true,"^17",["^18",["^8=",["^18",[[]]]]]],"^13","^5?","^6","missionary/core.cljc","^:",21,"^8?",["^18",[[]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",169,"^8N","^8M","^9",169,"^8D",0,"^8E",true,"^17",["^18",["^8=",["^18",[[]]]]]],"~$race",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",8,"^8<",true,"^8H",["^ ","^8C",true,"^8I",0,"^8D",0,"^8?",[[]],"^17",["^18",[[],["~$&","^9;"]]],"^8B",["^18",[null,null]]],"^8",4,"^7",118,"^9",118,"^17",["^18",["^8=",["^18",[[],["~$&","^9;"]]]]],"^1:","\nReturns a task running given `tasks` concurrently.\n\nIf any task succeeds, others are cancelled then `race` completes with this result.\n\nIf every task fails, `race` fails.\n\nCancelling propagates to children tasks.\n\nExample :\n```clojure\n(? (race (sleep 1000 1) (sleep 2000 2)))\n#_=> 1                 ;; 1 second later\n```\n"],"^13","^5@","^6","missionary/core.cljc","^:",8,"^8<",true,"^8H",["^ ","^8C",true,"^8I",0,"^8D",0,"^8?",[[]],"^17",["^18",[[],["~$&","^9;"]]],"^8B",["^18",[null,null]]],"^8?",[[]],"^8A",null,"^8I",0,"^8B",["^18",[null,null]],"^8",1,"^8C",true,"^8K",[["^ ","^8I",0,"^8C",false,"^8L","^8P"],["^ ","^8I",0,"^8C",true,"^8L","^8P"]],"^7",101,"^9",118,"^8D",0,"^8E",true,"^17",["^18",[[],["~$&","^9;"]]],"^1:","\nReturns a task running given `tasks` concurrently.\n\nIf any task succeeds, others are cancelled then `race` completes with this result.\n\nIf every task fails, `race` fails.\n\nCancelling propagates to children tasks.\n\nExample :\n```clojure\n(? (race (sleep 1000 1) (sleep 2000 2)))\n#_=> 1                 ;; 1 second later\n```\n"],"^10",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",14,"^8<",true,"^8H",["^ ","^8C",false,"^8I",3,"^8D",3,"^8?",[["^8O","~$f"],["^8O","~$i","~$f"]],"^17",["^18",[["^8O","~$f"],["^8O","~$i","~$f"]]],"^8B",["^18",[null,null]]],"^8",4,"^7",609,"^9",609,"^17",["^18",["^8=",["^18",[["^8O","~$f"],["^8O","~$i","~$f"]]]]],"^1:","\nReturns a discrete flow running given discrete `flow` and emitting given `init` value (or, if not provided, the result of calling `rf` with no argument) followed by successive reductions (by rf) of upstream values with previously emitted value.\n\nCancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (->> [1 2 3 4 5]\n        (seed)\n        (reductions +)\n        (reduce conj)))\n#_=> [0 1 3 6 10 15]\n```\n"],"^13","^3O","^6","missionary/core.cljc","^:",14,"^8<",true,"^8H",["^ ","^8C",false,"^8I",3,"^8D",3,"^8?",[["^8O","~$f"],["^8O","~$i","~$f"]],"^17",["^18",[["^8O","~$f"],["^8O","~$i","~$f"]]],"^8B",["^18",[null,null]]],"^8?",[["^8O","~$f"],["^8O","~$i","~$f"]],"^8A",null,"^8I",3,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^8K",[["^ ","^8I",2,"^8C",false,"^8L","^8P"],["^ ","^8I",3,"^8C",false,"^8L","^8P"]],"^7",593,"^9",609,"^8D",3,"^8E",true,"^17",["^18",[["^8O","~$f"],["^8O","~$i","~$f"]]],"^1:","\nReturns a discrete flow running given discrete `flow` and emitting given `init` value (or, if not provided, the result of calling `rf` with no argument) followed by successive reductions (by rf) of upstream values with previously emitted value.\n\nCancelling propagates to upstream flow. Early termination by `rf` (via `reduced` or throwing) cancels upstream flow.\n\nExample :\n```clojure\n(? (->> [1 2 3 4 5]\n        (seed)\n        (reductions +)\n        (reduce conj)))\n#_=> [0 1 3 6 10 15]\n```\n"],"~$compel",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",321,"^8",4,"^9",321,"^:",10,"^8<",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]],"^1:","\nInhibits cancellation signal of given `task`.\n"],"^13","^3V","^6","missionary/core.cljc","^:",10,"^8<",true,"^8?",["^18",[["^1J"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",316,"^8N","^8P","^9",321,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^1J"]]]]],"^1:","\nInhibits cancellation signal of given `task`.\n"],"~$ap-run",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",188,"^8",16,"^9",188,"^:",22,"^8G",true,"^17",["^18",["^8=",["^18",[["~$c","~$n","~$t"]]]]]],"^13","^3R","^6","missionary/core.cljc","^:",22,"^8?",["^18",[["~$c","~$n","~$t"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",188,"^8N","~$missionary.impl.Ambiguous/Process","^9",188,"^8D",3,"^8E",true,"^17",["^18",["^8=",["^18",[["~$c","~$n","~$t"]]]]]],"~$mbx",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",375,"^8",4,"^9",375,"^:",7,"^8<",true,"^17",["^18",["^8=",["^18",[[]]]]],"^1:","\nCreates an instance of mailbox.\n\nA mailbox is a function implementing `post` on 1-arity and `fetch` on 2-arity (as task). `post` immediately pushes given value to mailbox and returns nil. `fetch` is a task pulling a value from mailbox as soon as it's non-empty and completing with this value.\n\nCancelling a `fetch` task makes it fail immediately.\n\nExample : an actor is a mailbox associated with a process consuming messages.\n```clojure\n(defn crash [^Throwable e]                                ;; let it crash philosophy\n  (.printStackTrace e)\n  (System/exit -1))\n\n(defn actor\n  ([init] (actor init crash))\n  ([init fail]\n   (let [self (mbx)]\n     ((sp\n        (loop [b init]\n          (recur (b self (? self)))))\n       nil fail)\n     self)))\n\n(def counter\n  (actor\n    ((fn beh [n]\n       (fn [self cust]\n         (cust n)\n         (beh (inc n)))) 0)))\n\n(counter prn)                                             ;; prints 0\n(counter prn)                                             ;; prints 1\n(counter prn)                                             ;; prints 2\n```\n"],"^13","^5<","^6","missionary/core.cljc","^:",7,"^8<",true,"^8?",["^18",[[]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",338,"^8N","~$missionary.impl.Mailbox/Port","^9",375,"^8D",0,"^8E",true,"^17",["^18",["^8=",["^18",[[]]]]],"^1:","\nCreates an instance of mailbox.\n\nA mailbox is a function implementing `post` on 1-arity and `fetch` on 2-arity (as task). `post` immediately pushes given value to mailbox and returns nil. `fetch` is a task pulling a value from mailbox as soon as it's non-empty and completing with this value.\n\nCancelling a `fetch` task makes it fail immediately.\n\nExample : an actor is a mailbox associated with a process consuming messages.\n```clojure\n(defn crash [^Throwable e]                                ;; let it crash philosophy\n  (.printStackTrace e)\n  (System/exit -1))\n\n(defn actor\n  ([init] (actor init crash))\n  ([init fail]\n   (let [self (mbx)]\n     ((sp\n        (loop [b init]\n          (recur (b self (? self)))))\n       nil fail)\n     self)))\n\n(def counter\n  (actor\n    ((fn beh [n]\n       (fn [self cust]\n         (cust n)\n         (beh (inc n)))) 0)))\n\n(counter prn)                                             ;; prints 0\n(counter prn)                                             ;; prints 1\n(counter prn)                                             ;; prints 2\n```\n"],"~$reactor-call",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",797,"^8",4,"^9",797,"^:",16,"^8<",true,"^17",["^18",["^8=",["^18",[["~$boot"]]]]],"^1:","\nExperimental. To be deprecated in favor of [lazy publishers](https://github.com/leonoel/missionary/issues/70)\n"],"^13","^3W","^6","missionary/core.cljc","^:",16,"^8<",true,"^8?",["^18",[["~$i"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",794,"^8",16,"^9",794,"^:",24]]],"^8",1,"^8C",false,"^7",792,"^8N","^8P","^9",797,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^9N"]]]]],"^1:","\nExperimental. To be deprecated in favor of [lazy publishers](https://github.com/leonoel/missionary/issues/70)\n"],"~$cp*",["^ ","^8G",true,"^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",287,"^8",16,"^9",287,"^:",19,"^8G",true,"^17",["^18",["^8=",["^18",[["^O"]]]]]],"^13","^3U","^6","missionary/core.cljc","^:",19,"^8?",["^18",[["^O"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",287,"^8N","^8M","^9",287,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^O"]]]]]],"~$seed",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",482,"^8",4,"^9",482,"^:",8,"^8<",true,"^17",["^18",["^8=",["^18",[["~$coll"]]]]],"^1:","\nReturns a discrete flow producing values from given `collection`. Cancelling before having reached the end makes the flow fail immediately.\n"],"^13","^3Y","^6","missionary/core.cljc","^:",8,"^8<",true,"^8?",["^18",[["^9Q"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",477,"^8N","^8P","^9",482,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["^9Q"]]]]],"^1:","\nReturns a discrete flow producing values from given `collection`. Cancelling before having reached the end makes the flow fail immediately.\n"],"~$sample",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",734,"^8",4,"^9",734,"^:",10,"^8<",true,"^17",["^18",["^8=",["^18",[["~$f","~$sampled*","~$sampler"]]]]],"^1:","\nReturns a flow running an arbitrary number of sampled flows concurrently with a sampler flow. The process is ready to\ntransfer when the sampler is ready to transfer. On transfer, all ready inputs are transferred, the function is called\nwith the latest value of each input and the result is returned. If a sampled input emits consecutive values, all of\nthem are transferred and only the latest one is retained. Each sampled input must be initially ready.\n\nWhen the sampler input terminates, all sampled inputs are cancelled. Input failures and exceptions thrown by `f` cancel\nthe process, and propagate the error. The process terminates when all input flows are terminated. Cancelling the process\ncancels the sampler input.\n\nExample :\n```clojure\n(defn sleep-emit [delays]\n  (ap (let [n (?> (seed delays))]\n        (? (sleep n n)))))\n\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(m/? (->> (m/sample vector\n            (m/reductions {} 0 (sleep-emit [24 79 67 34]))\n            (sleep-emit [86 12 37 93]))\n       (delay-each 50)\n       (m/reduce conj)))\n\n#_=> [[24 86] [24 12] [79 37] [67 93]]\n```\n"],"^13","^4<","^6","missionary/core.cljc","^:",10,"^8<",true,"^8?",["^18",[["~$c","~$f","~$fs"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",706,"^8",16,"^9",706,"^:",38]]],"^8",1,"^8C",true,"^7",704,"^8N","^8P","^9",734,"^8D",2,"^8E",true,"^17",["^18",["^8=",["^18",[["~$f","^9S","^9T"]]]]],"^1:","\nReturns a flow running an arbitrary number of sampled flows concurrently with a sampler flow. The process is ready to\ntransfer when the sampler is ready to transfer. On transfer, all ready inputs are transferred, the function is called\nwith the latest value of each input and the result is returned. If a sampled input emits consecutive values, all of\nthem are transferred and only the latest one is retained. Each sampled input must be initially ready.\n\nWhen the sampler input terminates, all sampled inputs are cancelled. Input failures and exceptions thrown by `f` cancel\nthe process, and propagate the error. The process terminates when all input flows are terminated. Cancelling the process\ncancels the sampler input.\n\nExample :\n```clojure\n(defn sleep-emit [delays]\n  (ap (let [n (?> (seed delays))]\n        (? (sleep n n)))))\n\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(m/? (->> (m/sample vector\n            (m/reductions {} 0 (sleep-emit [24 79 67 34]))\n            (sleep-emit [86 12 37 93]))\n       (delay-each 50)\n       (m/reduce conj)))\n\n#_=> [[24 86] [24 12] [79 37] [67 93]]\n```\n"],"~$latest",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",701,"^8",4,"^9",701,"^:",10,"^8<",true,"^17",["^18",["^8=",["^18",[["~$f","~$&","~$flows"]]]]],"^1:","\nReturns a flow running an arbitrary number of flows concurrently. The process is ready to transfer when at least one\ninput is ready to transfer. On transfer, all ready inputs are transferred, the function is called with the latest\nvalue of each input and the result is returned. If an input emits consecutive values, all of them are transferred and\nonly the latest one is retained. Each input must be initially ready.\n\nInput failures and exceptions thrown by `f` cancel the process and propagate the error. The process terminates when all\ninputs are terminated. Cancelling the process cancels all inputs.\n\n```clojure\n(defn sleep-emit [delays]\n  (reductions {} 0\n    (ap (let [n (?> (seed delays))]\n          (? (sleep n n))))))\n\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(? (->> (latest vector\n          (sleep-emit [24 79 67 34])\n          (sleep-emit [86 12 37 93]))\n        (delay-each 50)\n        (reduce conj)))\n\n#_=> [[0 0] [24 0] [24 86] [79 12] [79 37] [67 37] [34 93]]\n```\n"],"^13","^4>","^6","missionary/core.cljc","^:",10,"^8<",true,"^8?",["^18",[["~$c","^9U"]]],"^8A",null,"^8B",["^18",[null,["^ ","^6","missionary/core.cljc","^7",674,"^8",16,"^9",674,"^:",29]]],"^8",1,"^8C",true,"^7",672,"^8N","^8P","^9",701,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["~$f","~$&","^9W"]]]]],"^1:","\nReturns a flow running an arbitrary number of flows concurrently. The process is ready to transfer when at least one\ninput is ready to transfer. On transfer, all ready inputs are transferred, the function is called with the latest\nvalue of each input and the result is returned. If an input emits consecutive values, all of them are transferred and\nonly the latest one is retained. Each input must be initially ready.\n\nInput failures and exceptions thrown by `f` cancel the process and propagate the error. The process terminates when all\ninputs are terminated. Cancelling the process cancels all inputs.\n\n```clojure\n(defn sleep-emit [delays]\n  (reductions {} 0\n    (ap (let [n (?> (seed delays))]\n          (? (sleep n n))))))\n\n(defn delay-each [delay input]\n  (ap (? (sleep delay (?> input)))))\n\n(? (->> (latest vector\n          (sleep-emit [24 79 67 34])\n          (sleep-emit [86 12 37 93]))\n        (delay-each 50)\n        (reduce conj)))\n\n#_=> [[0 0] [24 0] [24 86] [79 12] [79 37] [67 37] [34 93]]\n```\n"],"~$never",["^ ","^13","^4=","^6","missionary/core.cljc","^7",457,"^8",1,"^9",457,"^:",11,"^5",["^ ","^6","missionary/core.cljc","^7",457,"^8",6,"^9",457,"^:",11]],"~$sem",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",7,"^8<",true,"^8H",["^ ","^8C",false,"^8I",1,"^8D",1,"^8?",[[],["~$n"]],"^17",["^18",[[],["~$n"]]],"^8B",["^18",[null,null]]],"^8",4,"^7",444,"^9",444,"^17",["^18",["^8=",["^18",[[],["~$n"]]]]],"^1:","\nCreates a semaphore initialized with n tokens (1 if not provided, aka mutex).\n\nA semaphore is a function implementing `release` on 0-arity and `acquire` on 2-arity (as task). `release` immediately makes a token available and returns nil. `acquire` is a task completing with nil as soon as a token is available.\n\nCancelling an `acquire` task makes it fail immediately.\n\nExample : dining philosophers\n```clojure\n(defn phil [name f1 f2]\n  (sp\n    (while true\n      (prn name :thinking)\n      (? (sleep 500))\n      (holding f1\n        (holding f2\n          (prn name :eating)\n          (? (sleep 600)))))))\n\n(def forks (vec (repeatedly 5 sem)))\n\n(? (timeout 10000\n     (join vector\n       (phil \"descartes\" (forks 0) (forks 1))\n       (phil \"hume\"      (forks 1) (forks 2))\n       (phil \"plato\"     (forks 2) (forks 3))\n       (phil \"nietzsche\" (forks 3) (forks 4))\n       (phil \"kant\"      (forks 0) (forks 4)))))\n```\n"],"^13","^43","^6","missionary/core.cljc","^:",7,"^8<",true,"^8H",["^ ","^8C",false,"^8I",1,"^8D",1,"^8?",[[],["~$n"]],"^17",["^18",[[],["~$n"]]],"^8B",["^18",[null,null]]],"^8?",[[],["~$n"]],"^8A",null,"^8I",1,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^8K",[["^ ","^8I",0,"^8C",false,"^8L","^8M"],["^ ","^8I",1,"^8C",false,"^8L","~$missionary.impl.Semaphore/Port"]],"^7",412,"^9",444,"^8D",1,"^8E",true,"^17",["^18",[[],["~$n"]]],"^1:","\nCreates a semaphore initialized with n tokens (1 if not provided, aka mutex).\n\nA semaphore is a function implementing `release` on 0-arity and `acquire` on 2-arity (as task). `release` immediately makes a token available and returns nil. `acquire` is a task completing with nil as soon as a token is available.\n\nCancelling an `acquire` task makes it fail immediately.\n\nExample : dining philosophers\n```clojure\n(defn phil [name f1 f2]\n  (sp\n    (while true\n      (prn name :thinking)\n      (? (sleep 500))\n      (holding f1\n        (holding f2\n          (prn name :eating)\n          (? (sleep 600)))))))\n\n(def forks (vec (repeatedly 5 sem)))\n\n(? (timeout 10000\n     (join vector\n       (phil \"descartes\" (forks 0) (forks 1))\n       (phil \"hume\"      (forks 1) (forks 2))\n       (phil \"plato\"     (forks 2) (forks 3))\n       (phil \"nietzsche\" (forks 3) (forks 4))\n       (phil \"kant\"      (forks 0) (forks 4)))))\n```\n"],"~$zip",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^:",7,"^8<",true,"^8H",["^ ","^8C",true,"^8I",2,"^8D",2,"^8?",[["^18",["~$c","~$f","^9U"]]],"^17",["^18",[["~$c","~$f","~$&","^9U"]]],"^8B",["^18",[null]]],"^8",4,"^7",753,"^9",753,"^17",["^18",["^8=",["^18",[["~$c","~$f","~$&","^9U"]]]]],"^1:","\nReturns a discrete flow running given discrete `flows` concurrently and emitting the result of applying `f` to the set of first values emitted by each upstream flow, followed by the result of applying `f` to the set of second values and so on, until any upstream flow terminates, at which point the flow will cancel all other upstream flows and wait for their termination.\n\nCancelling propagates to every upstream flow. If any upstream flow fails or if `f` throws, the flow is cancelled.\n\nExample :\n```clojure\n(m/? (->> (m/zip vector\n                 (m/seed [1 2 3])\n                 (m/seed [:a :b :c]))\n          (m/reduce conj)))\n#_=> [[1 :a] [2 :b] [3 :c]]\n```\n"],"^13","^41","^6","missionary/core.cljc","^:",7,"^8<",true,"^8H",["^ ","^8C",true,"^8I",2,"^8D",2,"^8?",[["^18",["~$c","~$f","^9U"]]],"^17",["^18",[["~$c","~$f","~$&","^9U"]]],"^8B",["^18",[null]]],"^8?",[["^18",["~$c","~$f","^9U"]]],"^8A",null,"^8I",2,"^8B",["^18",[null]],"^8",1,"^8C",true,"^8K",[["^ ","^8I",2,"^8C",true,"^8L","^8P"]],"^7",737,"^8N","^8M","^9",753,"^8D",2,"^8E",true,"^17",["^18",[["~$c","~$f","~$&","^9U"]]],"^1:","\nReturns a discrete flow running given discrete `flows` concurrently and emitting the result of applying `f` to the set of first values emitted by each upstream flow, followed by the result of applying `f` to the set of second values and so on, until any upstream flow terminates, at which point the flow will cancel all other upstream flows and wait for their termination.\n\nCancelling propagates to every upstream flow. If any upstream flow fails or if `f` throws, the flow is cancelled.\n\nExample :\n```clojure\n(m/? (->> (m/zip vector\n                 (m/seed [1 2 3])\n                 (m/seed [:a :b :c]))\n          (m/reduce conj)))\n#_=> [[1 :a] [2 :b] [3 :c]]\n```\n"],"~$rdv",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",409,"^8",4,"^9",409,"^:",7,"^8<",true,"^17",["^18",["^8=",["^18",[[]]]]],"^1:","\nCreates an instance of synchronous rendez-vous.\n\nA synchronous rendez-vous is a function implementing `give` on its 1-arity and `take` on its 2-arity (as task). `give` takes a value to be transferred and returns a task completing with nil as soon as a taker is available. `take` is a task completing with transferred value as soon as a giver is available.\n\nCancelling `give` and `take` tasks makes them fail immediately.\n\nExample : producer / consumer stream communication\n```clojure\n(defn reducer [rf i take]\n  (sp\n    (loop [r i]\n      (let [x (? take)]\n        (if (identical? x take)\n          r (recur (rf r x)))))))\n\n(defn iterator [give xs]\n  (sp\n    (loop [xs (seq xs)]\n      (if-some [[x & xs] xs]\n        (do (? (give x))\n            (recur xs))\n        (? (give give))))))\n\n(def stream (rdv))\n\n(? (join {} (iterator stream (range 100)) (reducer + 0 stream)))      ;; returns 4950\n```\n"],"^13","^40","^6","missionary/core.cljc","^:",7,"^8<",true,"^8?",["^18",[[]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",378,"^8N","~$missionary.impl.Rendezvous/Port","^9",409,"^8D",0,"^8E",true,"^17",["^18",["^8=",["^18",[[]]]]],"^1:","\nCreates an instance of synchronous rendez-vous.\n\nA synchronous rendez-vous is a function implementing `give` on its 1-arity and `take` on its 2-arity (as task). `give` takes a value to be transferred and returns a task completing with nil as soon as a taker is available. `take` is a task completing with transferred value as soon as a giver is available.\n\nCancelling `give` and `take` tasks makes them fail immediately.\n\nExample : producer / consumer stream communication\n```clojure\n(defn reducer [rf i take]\n  (sp\n    (loop [r i]\n      (let [x (? take)]\n        (if (identical? x take)\n          r (recur (rf r x)))))))\n\n(defn iterator [give xs]\n  (sp\n    (loop [xs (seq xs)]\n      (if-some [[x & xs] xs]\n        (do (? (give x))\n            (recur xs))\n        (? (give give))))))\n\n(def stream (rdv))\n\n(? (join {} (iterator stream (range 100)) (reducer + 0 stream)))      ;; returns 4950\n```\n"],"~$watch",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",552,"^8",4,"^9",552,"^:",9,"^8<",true,"^17",["^18",["^8=",["^18",[["~$r"]]]]],"^1:","\nReturns a continuous flow reflecting the current state of a reference type. `reference` must support `add-watch`,\n`remove-watch` and `deref`. On initialization, the process is ready to transfer. On transfer, the current state is\nreturned. Whenever the state of the reference changes and a transfer is not pending, the process becomes ready to\ntransfer again. Cancelling the process makes it fail immediately with an instance of `missionary.Cancelled` and\nterminates the process.\n"],"^13","^48","^6","missionary/core.cljc","^:",9,"^8<",true,"^8?",["^18",[["~$r"]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",543,"^8N","^8P","^9",552,"^8D",1,"^8E",true,"^17",["^18",["^8=",["^18",[["~$r"]]]]],"^1:","\nReturns a continuous flow reflecting the current state of a reference type. `reference` must support `add-watch`,\n`remove-watch` and `deref`. On initialization, the process is ready to transfer. On transfer, the current state is\nreturned. Whenever the state of the reference changes and a transfer is not pending, the process becomes ready to\ntransfer again. Cancelling the process makes it fail immediately with an instance of `missionary.Cancelled` and\nterminates the process.\n"],"~$dfv",["^ ","^8;",null,"^5",["^ ","^6","missionary/core.cljc","^7",335,"^8",4,"^9",335,"^:",7,"^8<",true,"^17",["^18",["^8=",["^18",[[]]]]],"^1:","\nCreates an instance of dataflow variable (aka single-assignment).\n\nA dataflow variable is a function implementing `assign` on 1-arity and `deref` on 2-arity (as task). `assign` immediately binds the variable to given value if not already bound and returns bound value. `deref` is a task completing with the value bound to the variable as soon as it's available.\n\nCancelling a `deref` task makes it fail immediately.\n```\n"],"^13","^49","^6","missionary/core.cljc","^:",7,"^8<",true,"^8?",["^18",[[]]],"^8A",null,"^8B",["^18",[null,null]],"^8",1,"^8C",false,"^7",325,"^8N","~$missionary.impl.Dataflow/Port","^9",335,"^8D",0,"^8E",true,"^17",["^18",["^8=",["^18",[[]]]]],"^1:","\nCreates an instance of dataflow variable (aka single-assignment).\n\nA dataflow variable is a function implementing `assign` on 1-arity and `deref` on 2-arity (as task). `assign` immediately binds the variable to given value if not already bound and returns bound value. `deref` is a task completing with the value bound to the variable as soon as it's available.\n\nCancelling a `deref` task makes it fail immediately.\n```\n"]],"^31",["^ ","^P","^P","^H","^H","^E","^E"],"~:cljs.analyzer/constants",["^ ","^2[",["^X",["^8<","~:missionary.core/errors","^1:"]],"~:order",["^:6","^8<","^1:"]],"^3;",["^ ","^30",["^X",[]],"^31",["^X",[]]],"^3<",["^ "],"^3=",["^2Z","^E","^P","^2>","^2D","^2J","^2H","^2<","^2F","^1X","^2T","^20","^2L","^2P","^2X","^24","^2:","^2B","^22","^1Z","^2V","^2@","^26","^2N","^2R","^28","^1V"]],"^12","^H","~:ns-specs",["^ "],"~:ns-spec-vars",["^X",[]],"~:compiler-options",["^5I",[["^::","~:static-fns"],true,["^::","~:shadow-tweaks"],null,["^::","~:source-map-inline"],null,["^::","~:elide-asserts"],false,["^::","~:optimize-constants"],null,["^::","^3B"],null,["^::","~:external-config"],null,["^::","~:tooling-config"],null,["^::","~:emit-constants"],null,["^::","~:load-tests"],null,["^::","~:form-size-threshold"],null,["^::","~:global-goog-object&array"],null,["^::","~:data-readers"],null,["^::","~:infer-externs"],"~:auto",["^::","^3D"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^::","~:fn-invoke-direct"],null,["^::","~:source-map"],"/dev/null"]]]